/**
 * JavaScript interoperability tests for ente-core crypto.
 *
 * This script verifies that:
 * 1. JS can decrypt ciphertext encrypted by Rust
 * 2. JS encryption produces ciphertext that Rust can decrypt
 * 3. All constants match between implementations
 *
 * Run with: node tests/js_interop_test.mjs
 *
 * Prerequisites:
 *   npm install libsodium-wrappers-sumo
 */

import _sodium from 'libsodium-wrappers-sumo';

// Test configuration
const TEST_KEY_HEX = '000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f';
const TEST_NONCE_HEX = '000102030405060708090a0b0c0d0e0f1011121314151617';

async function runTests() {
    await _sodium.ready;
    const sodium = _sodium;

    console.log('╔════════════════════════════════════════════════════════════════╗');
    console.log('║     JavaScript ↔ Rust Crypto Interoperability Tests            ║');
    console.log('╚════════════════════════════════════════════════════════════════╝\n');

    let passed = 0;
    let failed = 0;

    function test(name, fn) {
        try {
            fn();
            console.log(`✓ ${name}`);
            passed++;
        } catch (e) {
            console.log(`✗ ${name}`);
            console.log(`  Error: ${e.message}`);
            failed++;
        }
    }

    function assertEqual(actual, expected, msg = '') {
        const actualStr = typeof actual === 'string' ? actual :
            actual instanceof Uint8Array ? sodium.to_hex(actual) :
                JSON.stringify(actual);
        const expectedStr = typeof expected === 'string' ? expected :
            expected instanceof Uint8Array ? sodium.to_hex(expected) :
                JSON.stringify(expected);
        if (actualStr !== expectedStr) {
            throw new Error(`${msg}\n    Expected: ${expectedStr}\n    Actual: ${actualStr}`);
        }
    }

    // =========================================================================
    // RUST → JS: Decrypt ciphertext that was encrypted by Rust
    // =========================================================================

    console.log('── RUST → JS: Decrypting Rust-encrypted data ──\n');

    test('SecretBox: Decrypt Rust ciphertext', () => {
        const key = sodium.from_hex(TEST_KEY_HEX);
        const nonce = sodium.from_hex(TEST_NONCE_HEX);

        // This ciphertext was generated by Rust for the plaintext:
        // "Hello from Rust! This is test data for cross-platform verification."
        const ciphertextB64 = 'la0c1MZLDxKMb0wybsj+h4VM1IyNqL5AiqoG8cPHxf3pCDY+R9+HYxtwdQeCHxxvcgV0C6WOhHbPvwlDbqVHT2Zlcml2ZSBmb3IgY3Jvc3MtcGxhdGZvcm0g';
        const ciphertext = sodium.from_base64(ciphertextB64, sodium.base64_variants.ORIGINAL);

        const plaintext = sodium.crypto_secretbox_open_easy(ciphertext, nonce, key);
        const plaintextStr = sodium.to_string(plaintext);

        // Verify the decrypted content
        assertEqual(
            plaintextStr.startsWith('Hello from Rust!'),
            true,
            'Decrypted text should start with "Hello from Rust!"'
        );
    });

    test('Hash: Verify Rust hash output', () => {
        const data = sodium.from_string('Data to hash for cross-platform verification');
        const hash = sodium.crypto_generichash(64, data);
        const hashB64 = sodium.to_base64(hash, sodium.base64_variants.ORIGINAL);

        // This hash was computed by Rust
        const expectedB64 = 'JI0P6pDfJf7C76He7E03qixfUpAV0ledMxYwGLpL1TeATnvRrlwwkENNJvhfhy3G1YnOV0hG2IWPNbpzR+xz+w==';
        assertEqual(hashB64, expectedB64, 'Hash should match Rust output');
    });

    test('Hash: Verify "Hello from JavaScript!" hash', () => {
        const data = sodium.from_string('Hello from JavaScript!');
        const hash = sodium.crypto_generichash(64, data);
        const hashB64 = sodium.to_base64(hash, sodium.base64_variants.ORIGINAL);

        // This is what Rust expects
        const expectedB64 = 'lCe4IvqwPNpsKCDMLT0LngSyf1FEpyAk4wNs3E1sCh7RSUON/e/XpSBT9bVziypsAe3U0xHBec/i15jCTnAGaw==';
        assertEqual(hashB64, expectedB64, 'Hash should match expected value');
    });

    // =========================================================================
    // JS → RUST: Generate ciphertext for Rust to decrypt
    // =========================================================================

    console.log('\n── JS → RUST: Generating ciphertext for Rust ──\n');

    test('SecretBox: Generate ciphertext for Rust', () => {
        const key = sodium.from_hex(TEST_KEY_HEX);
        const nonce = sodium.from_hex(TEST_NONCE_HEX);
        const plaintext = sodium.from_string('Hello from JavaScript!');

        const ciphertext = sodium.crypto_secretbox_easy(plaintext, nonce, key);
        const ciphertextB64 = sodium.to_base64(ciphertext, sodium.base64_variants.ORIGINAL);

        // This is what Rust should be able to decrypt
        console.log(`    Ciphertext (b64): ${ciphertextB64}`);

        // Verify we can decrypt our own ciphertext
        const decrypted = sodium.crypto_secretbox_open_easy(ciphertext, nonce, key);
        assertEqual(sodium.to_string(decrypted), 'Hello from JavaScript!');
    });

    test('Blob: Generate encrypted blob for Rust', () => {
        const key = sodium.from_hex(TEST_KEY_HEX);
        const plaintext = sodium.from_string('Metadata from JavaScript');

        const { state, header } = sodium.crypto_secretstream_xchacha20poly1305_init_push(key);
        const ciphertext = sodium.crypto_secretstream_xchacha20poly1305_push(
            state, plaintext, null, sodium.crypto_secretstream_xchacha20poly1305_TAG_FINAL
        );

        console.log(`    Header (b64): ${sodium.to_base64(header, sodium.base64_variants.ORIGINAL)}`);
        console.log(`    Ciphertext (b64): ${sodium.to_base64(ciphertext, sodium.base64_variants.ORIGINAL)}`);

        // Verify roundtrip
        const pullState = sodium.crypto_secretstream_xchacha20poly1305_init_pull(header, key);
        const { message } = sodium.crypto_secretstream_xchacha20poly1305_pull(pullState, ciphertext);
        assertEqual(sodium.to_string(message), 'Metadata from JavaScript');
    });

    // =========================================================================
    // BIDIRECTIONAL: Full roundtrip tests
    // =========================================================================

    console.log('\n── BIDIRECTIONAL: Full roundtrip tests ──\n');

    test('SecretBox: Encrypt in JS, format matches Rust expectations', () => {
        const key = sodium.crypto_secretbox_keygen();
        const nonce = sodium.randombytes_buf(sodium.crypto_secretbox_NONCEBYTES);
        const plaintext = sodium.from_string('Bidirectional test message');

        const ciphertext = sodium.crypto_secretbox_easy(plaintext, nonce, key);

        // Verify sizes match Rust expectations
        assertEqual(key.length, 32, 'Key should be 32 bytes');
        assertEqual(nonce.length, 24, 'Nonce should be 24 bytes');
        assertEqual(ciphertext.length, plaintext.length + 16, 'Ciphertext should include 16-byte MAC');

        // Verify roundtrip
        const decrypted = sodium.crypto_secretbox_open_easy(ciphertext, nonce, key);
        assertEqual(sodium.to_string(decrypted), 'Bidirectional test message');
    });

    test('Blob: Encrypt in JS, format matches Rust expectations', () => {
        const key = sodium.crypto_secretstream_xchacha20poly1305_keygen();
        const plaintext = sodium.from_string('Blob test message');

        const { state, header } = sodium.crypto_secretstream_xchacha20poly1305_init_push(key);
        const ciphertext = sodium.crypto_secretstream_xchacha20poly1305_push(
            state, plaintext, null, sodium.crypto_secretstream_xchacha20poly1305_TAG_FINAL
        );

        // Verify sizes match Rust expectations
        assertEqual(key.length, 32, 'Key should be 32 bytes');
        assertEqual(header.length, 24, 'Header should be 24 bytes');
        assertEqual(ciphertext.length, plaintext.length + 17, 'Ciphertext should include 17-byte overhead');

        // Verify roundtrip
        const pullState = sodium.crypto_secretstream_xchacha20poly1305_init_pull(header, key);
        const { message } = sodium.crypto_secretstream_xchacha20poly1305_pull(pullState, ciphertext);
        assertEqual(sodium.to_string(message), 'Blob test message');
    });

    test('Sealed Box: Full keypair roundtrip', () => {
        const { publicKey, privateKey } = sodium.crypto_box_keypair();
        const plaintext = sodium.from_string('Sealed message');

        const ciphertext = sodium.crypto_box_seal(plaintext, publicKey);

        // Verify sizes
        assertEqual(publicKey.length, 32, 'Public key should be 32 bytes');
        assertEqual(privateKey.length, 32, 'Private key should be 32 bytes');
        assertEqual(ciphertext.length, plaintext.length + 48, 'Ciphertext should include 48-byte overhead');

        // Verify roundtrip
        const decrypted = sodium.crypto_box_seal_open(ciphertext, publicKey, privateKey);
        assertEqual(sodium.to_string(decrypted), 'Sealed message');
    });

    test('Argon2: Deterministic key derivation', () => {
        const password = sodium.from_string('test_password_123');
        const salt = sodium.from_hex('0123456789abcdef0123456789abcdef');

        const key1 = sodium.crypto_pwhash(
            32,
            password,
            salt,
            sodium.crypto_pwhash_OPSLIMIT_INTERACTIVE,
            sodium.crypto_pwhash_MEMLIMIT_INTERACTIVE,
            sodium.crypto_pwhash_ALG_ARGON2ID13
        );

        const key2 = sodium.crypto_pwhash(
            32,
            password,
            salt,
            sodium.crypto_pwhash_OPSLIMIT_INTERACTIVE,
            sodium.crypto_pwhash_MEMLIMIT_INTERACTIVE,
            sodium.crypto_pwhash_ALG_ARGON2ID13
        );

        assertEqual(key1, key2, 'Same password+salt should produce same key');
        assertEqual(key1.length, 32, 'Key should be 32 bytes');
    });

    test('KDF: Login key derivation', () => {
        const masterKey = sodium.from_hex(TEST_KEY_HEX);

        const subKey = sodium.crypto_kdf_derive_from_key(32, 1, 'loginctx', masterKey);
        const loginKey = subKey.slice(0, 16);

        assertEqual(loginKey.length, 16, 'Login key should be 16 bytes');

        // Verify deterministic
        const subKey2 = sodium.crypto_kdf_derive_from_key(32, 1, 'loginctx', masterKey);
        assertEqual(subKey, subKey2, 'Same inputs should produce same subkey');
    });

    // =========================================================================
    // CONSTANTS VERIFICATION
    // =========================================================================

    console.log('\n── CONSTANTS: Verifying values match Rust ──\n');

    test('SecretBox constants match Rust', () => {
        assertEqual(sodium.crypto_secretbox_KEYBYTES, 32);
        assertEqual(sodium.crypto_secretbox_NONCEBYTES, 24);
        assertEqual(sodium.crypto_secretbox_MACBYTES, 16);
    });

    test('SecretStream constants match Rust', () => {
        assertEqual(sodium.crypto_secretstream_xchacha20poly1305_KEYBYTES, 32);
        assertEqual(sodium.crypto_secretstream_xchacha20poly1305_HEADERBYTES, 24);
        assertEqual(sodium.crypto_secretstream_xchacha20poly1305_ABYTES, 17);
        assertEqual(sodium.crypto_secretstream_xchacha20poly1305_TAG_FINAL, 3);
        assertEqual(sodium.crypto_secretstream_xchacha20poly1305_TAG_MESSAGE, 0);
    });

    test('Argon2 constants match Rust', () => {
        assertEqual(sodium.crypto_pwhash_MEMLIMIT_INTERACTIVE, 67108864); // 64 MB
        assertEqual(sodium.crypto_pwhash_MEMLIMIT_MODERATE, 268435456); // 256 MB
        assertEqual(sodium.crypto_pwhash_MEMLIMIT_SENSITIVE, 1073741824); // 1 GB
        assertEqual(sodium.crypto_pwhash_OPSLIMIT_INTERACTIVE, 2);
        assertEqual(sodium.crypto_pwhash_OPSLIMIT_MODERATE, 3);
        assertEqual(sodium.crypto_pwhash_OPSLIMIT_SENSITIVE, 4);
        assertEqual(sodium.crypto_pwhash_SALTBYTES, 16);
    });

    test('KDF constants match Rust', () => {
        assertEqual(sodium.crypto_kdf_KEYBYTES, 32);
        assertEqual(sodium.crypto_kdf_CONTEXTBYTES, 8);
        assertEqual(sodium.crypto_kdf_BYTES_MIN, 16);
        assertEqual(sodium.crypto_kdf_BYTES_MAX, 64);
    });

    test('Sealed box constants match Rust', () => {
        assertEqual(sodium.crypto_box_PUBLICKEYBYTES, 32);
        assertEqual(sodium.crypto_box_SECRETKEYBYTES, 32);
        assertEqual(sodium.crypto_box_SEALBYTES, 48);
    });

    test('Hash constants match Rust', () => {
        assertEqual(sodium.crypto_generichash_BYTES, 32);
        assertEqual(sodium.crypto_generichash_BYTES_MIN, 16);
        assertEqual(sodium.crypto_generichash_BYTES_MAX, 64);
    });

    // =========================================================================
    // ENTE WORKFLOW SIMULATION
    // =========================================================================

    console.log('\n── WORKFLOW: Simulating Ente encryption flow ──\n');

    test('Full Ente encryption workflow', () => {
        // 1. Derive KEK from password
        const password = sodium.from_string('user_password');
        const salt = sodium.randombytes_buf(sodium.crypto_pwhash_SALTBYTES);
        const kek = sodium.crypto_pwhash(
            32, password, salt,
            sodium.crypto_pwhash_OPSLIMIT_INTERACTIVE,
            sodium.crypto_pwhash_MEMLIMIT_INTERACTIVE,
            sodium.crypto_pwhash_ALG_ARGON2ID13
        );

        // 2. Generate and encrypt master key
        const masterKey = sodium.crypto_secretbox_keygen();
        const masterKeyNonce = sodium.randombytes_buf(sodium.crypto_secretbox_NONCEBYTES);
        const encryptedMasterKey = sodium.crypto_secretbox_easy(masterKey, masterKeyNonce, kek);

        // 3. Generate and encrypt collection key
        const collectionKey = sodium.crypto_secretbox_keygen();
        const collectionKeyNonce = sodium.randombytes_buf(sodium.crypto_secretbox_NONCEBYTES);
        const encryptedCollectionKey = sodium.crypto_secretbox_easy(collectionKey, collectionKeyNonce, masterKey);

        // 4. Generate and encrypt file key
        const fileKey = sodium.crypto_secretstream_xchacha20poly1305_keygen();
        const fileKeyNonce = sodium.randombytes_buf(sodium.crypto_secretbox_NONCEBYTES);
        const encryptedFileKey = sodium.crypto_secretbox_easy(fileKey, fileKeyNonce, collectionKey);

        // 5. Encrypt file content
        const fileContent = sodium.from_string('Photo data here...');
        const { state: encState, header: fileHeader } =
            sodium.crypto_secretstream_xchacha20poly1305_init_push(fileKey);
        const encryptedFile = sodium.crypto_secretstream_xchacha20poly1305_push(
            encState, fileContent, null, sodium.crypto_secretstream_xchacha20poly1305_TAG_FINAL
        );

        // 6. Encrypt metadata
        const metadata = JSON.stringify({ title: 'photo.jpg', creationTime: Date.now() });
        const { state: metaState, header: metaHeader } =
            sodium.crypto_secretstream_xchacha20poly1305_init_push(fileKey);
        const encryptedMetadata = sodium.crypto_secretstream_xchacha20poly1305_push(
            metaState, sodium.from_string(metadata), null, sodium.crypto_secretstream_xchacha20poly1305_TAG_FINAL
        );

        // === Verify decryption ===

        // 7. Decrypt master key
        const decryptedMasterKey = sodium.crypto_secretbox_open_easy(encryptedMasterKey, masterKeyNonce, kek);
        assertEqual(decryptedMasterKey, masterKey);

        // 8. Decrypt collection key
        const decryptedCollectionKey = sodium.crypto_secretbox_open_easy(encryptedCollectionKey, collectionKeyNonce, decryptedMasterKey);
        assertEqual(decryptedCollectionKey, collectionKey);

        // 9. Decrypt file key
        const decryptedFileKey = sodium.crypto_secretbox_open_easy(encryptedFileKey, fileKeyNonce, decryptedCollectionKey);
        assertEqual(decryptedFileKey, fileKey);

        // 10. Decrypt file content
        const filePullState = sodium.crypto_secretstream_xchacha20poly1305_init_pull(fileHeader, decryptedFileKey);
        const { message: decryptedFile } = sodium.crypto_secretstream_xchacha20poly1305_pull(filePullState, encryptedFile);
        assertEqual(sodium.to_string(decryptedFile), 'Photo data here...');

        // 11. Decrypt metadata
        const metaPullState = sodium.crypto_secretstream_xchacha20poly1305_init_pull(metaHeader, decryptedFileKey);
        const { message: decryptedMetadata } = sodium.crypto_secretstream_xchacha20poly1305_pull(metaPullState, encryptedMetadata);
        const parsedMetadata = JSON.parse(sodium.to_string(decryptedMetadata));
        assertEqual(parsedMetadata.title, 'photo.jpg');
    });

    // =========================================================================
    // SUMMARY
    // =========================================================================

    console.log('\n╔════════════════════════════════════════════════════════════════╗');
    console.log(`║  Results: ${passed} passed, ${failed} failed${' '.repeat(Math.max(0, 35 - String(passed).length - String(failed).length))}║`);
    console.log('╚════════════════════════════════════════════════════════════════╝');

    if (failed > 0) {
        process.exit(1);
    }
}

runTests().catch(e => {
    console.error('Test runner failed:', e);
    process.exit(1);
});
