<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Session Export - 2025-11-26T19-05-04-183Z_78deff5d-8746-4092-a618-531fe3042ace.jsonl</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            color: rgb(229, 229, 231);
            background: rgb(24, 24, 30);
            padding: 24px;
        }

        .container {
            max-width: 700px;
            margin: 0 auto;
        }

        .header {
            margin-bottom: 24px;
            padding: 16px;
            background: rgb(30, 30, 36);
            border-radius: 4px;
        }

        .header h1 {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 12px;
            color: rgb(103, 232, 249);
        }

        .header-info {
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 13px;
        }

        .info-item {
            color: rgb(161, 161, 170);
            display: flex;
            align-items: baseline;
        }

        .info-label {
            font-weight: 600;
            margin-right: 8px;
            min-width: 80px;
        }

        .info-value {
            color: rgb(229, 229, 231);
            flex: 1;
        }

        .messages {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        /* User message - matching TUI UserMessageComponent */
        .user-message {
            background: rgb(52, 53, 65);
            padding: 12px 16px;
            border-radius: 4px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* Assistant text - matching TUI AssistantMessageComponent */
        .assistant-text {
            padding: 12px 16px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* Thinking text - gray italic */
        .thinking-text {
            padding: 12px 16px;
            color: rgb(161, 161, 170);
            font-style: italic;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* Tool execution - matching TUI ToolExecutionComponent */
        .tool-execution {
            padding: 12px 16px;
            border-radius: 4px;
            margin-top: 8px;
        }

        .tool-header {
            font-weight: bold;
        }

        .tool-name {
            font-weight: bold;
        }

        .tool-path {
            color: rgb(103, 232, 249);
        }

        .line-count {
            color: rgb(161, 161, 170);
        }

        .tool-command {
            font-weight: bold;
        }

        .tool-output {
            margin-top: 12px;
            color: rgb(161, 161, 170);
            white-space: pre-wrap;
            font-family: inherit;
        }

        .tool-output > div {
            line-height: 1.4;
        }

        .tool-output pre {
            margin: 0;
            font-family: inherit;
            color: inherit;
        }

        /* Expandable tool output */
        .tool-output.expandable {
            cursor: pointer;
        }

        .tool-output.expandable:hover {
            opacity: 0.9;
        }

        .tool-output.expandable .output-full {
            display: none;
        }

        .tool-output.expandable.expanded .output-preview {
            display: none;
        }

        .tool-output.expandable.expanded .output-full {
            display: block;
        }

        .expand-hint {
            color: rgb(103, 232, 249);
            font-style: italic;
            margin-top: 4px;
        }

        /* System prompt section */
        .system-prompt {
            background: rgb(60, 55, 40);
            padding: 12px 16px;
            border-radius: 4px;
            margin-bottom: 16px;
        }

        .system-prompt-header {
            font-weight: bold;
            color: rgb(234, 179, 8);
            margin-bottom: 8px;
        }

        .system-prompt-content {
            color: rgb(161, 161, 170);
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 13px;
        }

        .tools-list {
            background: rgb(60, 55, 40);
            padding: 12px 16px;
            border-radius: 4px;
            margin-bottom: 16px;
        }

        .tools-header {
            font-weight: bold;
            color: rgb(234, 179, 8);
            margin-bottom: 8px;
        }

        .tools-content {
            color: rgb(161, 161, 170);
            font-size: 13px;
        }

        .tool-item {
            margin: 4px 0;
        }

        .tool-item-name {
            font-weight: bold;
            color: rgb(229, 229, 231);
        }

        /* Diff styling */
        .tool-diff {
            margin-top: 12px;
            font-size: 13px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            overflow-x: auto;
            max-width: 100%;
        }

        .diff-line-old {
            color: rgb(239, 68, 68);
            white-space: pre;
        }

        .diff-line-new {
            color: rgb(34, 197, 94);
            white-space: pre;
        }

        .diff-line-context {
            color: rgb(161, 161, 170);
            white-space: pre;
        }

        /* Error text */
        .error-text {
            color: rgb(239, 68, 68);
            padding: 12px 16px;
        }

        .footer {
            margin-top: 48px;
            padding: 20px;
            text-align: center;
            color: rgb(161, 161, 170);
            font-size: 12px;
        }

        @media print {
            body {
                background: white;
                color: black;
            }
            .tool-execution {
                border: 1px solid #ddd;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>pi v0.9.4</h1>
            <div class="header-info">
                <div class="info-item">
                    <span class="info-label">Session:</span>
                    <span class="info-value">78deff5d-8746-4092-a618-531fe3042ace</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Date:</span>
                    <span class="info-value">11/27/2025, 12:36:16 AM</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Model:</span>
                    <span class="info-value">claude-opus-4-5</span>
                </div>
            </div>
        </div>

        <div class="header">
            <h1>Messages</h1>
            <div class="header-info">
                <div class="info-item">
                    <span class="info-label">User:</span>
                    <span class="info-value">3</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Assistant:</span>
                    <span class="info-value">20</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Tool Calls:</span>
                    <span class="info-value">29</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Tool Results:</span>
                    <span class="info-value">29</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Total:</span>
                    <span class="info-value">52</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Directory:</span>
                    <span class="info-value">~/dev/enteio/ente/mobile/apps/photos</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Thinking:</span>
                    <span class="info-value">off</span>
                </div>
            </div>
        </div>

        <div class="system-prompt">
            <div class="system-prompt-header">System Prompt</div>
            <div class="system-prompt-content">You are actually not Claude, you are Pi. You are an expert coding assistant. You help users with coding tasks by reading files, executing commands, editing code, and writing new files.

Available tools:
- read: Read file contents
- bash: Execute bash commands (ls, grep, find, etc.)
- edit: Make surgical edits to files (find exact text and replace)
- write: Create or overwrite files

Guidelines:
- Always use bash tool for file operations like ls, grep, find
- Use read to examine files before editing
- Use edit for precise changes (old text must match exactly)
- Use write only for new files or complete rewrites
- Be concise in your responses
- Show file paths clearly when working with files
- When summarizing your actions, output plain text directly - do NOT use cat or bash to display what you did

Documentation:
- Your own documentation (including custom model setup and theme creation) is at: /usr/local/bin/node/lib/node_modules/@mariozechner/pi-coding-agent/README.md
- Read it when users ask about features, configuration, or setup, and especially if the user asks you to add a custom model or provider, or create a custom theme.

# Project Context

The following project context files have been loaded:

## /Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/AGENTS.md

# Repository Guidelines

## Project Philosophy
- Protect user privacy and preserve end-to-end encryption integrity in every change.
- Keep implementations transparent and auditable to sustain user trust.
- Design with zero-knowledge architecture assumptions so sensitive data never leaves the user’s control.

## Monorepo Context
- This Photos app lives inside the Ente monorepo alongside Auth, Locker, web, desktop, CLI, and backend code.
- Shared Flutter packages sit under `mobile/packages/`; Photos-specific Flutter plugins live in `mobile/apps/photos/plugins/`.

## Project Structure &amp; Module Organization
`lib/` houses the Flutter client (`core/`, `services/`, `ui/`, `db/`). Tests live in `test/` (unit &amp; widget) and `integration_test/`. Platform shells are `android/` and `ios/`; Rust crates and bridge helpers sit in `rust/` and `rust_builder/`. Assets, fonts, and localization configs are in `assets/`, `fonts/`, `l10n.yaml`, with generated code in `lib/generated/`. Automation scripts include `scripts/`, `run.sh`, `build-apk.sh`, and release tooling under `fastlane/`.

## Build, Test &amp; Development Commands
Run `flutter pub get` after dependency edits. Launch the dev flavor via `./run.sh` (reads `.env`) or use `flutter run -t lib/main.dart --flavor independent`. Regenerate Rust bindings with `flutter_rust_bridge_codegen generate` before builds. Android releases rely on `flutter build apk --release --flavor independent`; for iOS run `cd ios &amp;&amp; pod install` then `flutter build ios`. Use `./build-apk.sh` when Gradle artifacts from `thirdparty/transistor-background-fetch` need refreshing.

## Coding Style &amp; Naming Conventions
Use 2-space indentation and format with `dart format .` (trailing commas preserved). `analysis_options.yaml` enforces rules such as `prefer_const_constructors`, `require_trailing_commas`, and `always_use_package_imports`. Keep files `snake_case.dart`, classes `PascalCase`, private members `_camelCase`. Avoid `print`; rely on the log utilities under `lib/core/`.

## Testing Guidelines
Mirror source names with `*_test.dart`. Run only suites that cover your changes—`flutter test` (or a filtered target) when relevant tests exist, and skip it if no tests touch your work. Device flows stay in `integration_test/` (`flutter test integration_test`). Rust-facing updates should extend coverage with `cargo test` plus Dart adapter checks. Document new fixtures or goldens in `docs/`.

## Commit &amp; Pull Request Guidelines
Commits should stay concise and imperative, summarising all substantial code changes. PR titles must tag the scope: `[mob][photos] …` for this app, else `[mob][auth]`, `[mob][locker]`, `[mob][packages]`, `[web]`, `[desktop]`, `[server]`, `[infra]`, or package-specific tags like `[mob][native_video_editor]`. Use `.github/pull_request_template.md` as your outline. Populate the Tests section with Markdown checkboxes covering only the validations needed pre-merge (keep it tight, relevant, and ≤5 items); omit the entire section when nothing needs to run. Add QA notes and UI captures when applicable, and verify `flutter analyze .` plus only the applicable tests from above before submitting.

## Rust &amp; Localization Notes
Regenerate Dart bindings when Rust APIs change and keep generated code in `lib/src/rust/`. Exercise Rust crates with `cargo test` during such updates. For copy edits, update `lib/l10n/intl_en.arb` then run `flutter gen-l10n` (configured by `l10n.yaml`) to refresh `lib/generated/`, and coordinate Crowdin syncs through `crowdin.yml`.

## Development Setup Requirements
1. Install Flutter `3.32.8` with a Dart SDK between `&gt;=3.3.0 &lt;4.0.0`.
2. Install Rust along with `flutter_rust_bridge_codegen` via `cargo install flutter_rust_bridge_codegen`.
3. Regenerate Rust bindings whenever native APIs shift using `flutter_rust_bridge_codegen generate`.
4. Initialize and refresh git submodules with `git submodule update --init --recursive`.
5. Point git hooks at the repository hooks directory: `git config core.hooksPath hooks`.

## Critical Practices
- `dart format .` must run before you commit so the tree stays uniformly formatted.
- Follow each edit with `flutter analyze` and resolve every warning or info message introduced by the change.
- Reuse existing UI and service components; search both `lib/ui/` and `../../packages/` before creating new primitives.
- Respect the design system—pull colors from `getEnteColorScheme(context)` and text styles from `getEnteTextTheme(context)`, caching the theme at the top of `build`.
- Keep specs and docs in sync with code updates; when behavior shifts, revise the relevant files under `docs/` or adjacent directories.


Current date and time: Thursday, November 27, 2025 at 12:35:04 AM GMT+5:30
Current working directory: /Users/prateeksunal/dev/enteio/ente/mobile/apps/photos</div>
        </div>

        <div class="tools-list">
            <div class="tools-header">Available Tools</div>
            <div class="tools-content">
                <div class="tool-item"><span class="tool-item-name">read</span> - Read the contents of a file. Supports text files and images (jpg, png, gif, webp). Images are sent as attachments. For text files, defaults to first 2000 lines. Use offset/limit for large files.</div><div class="tool-item"><span class="tool-item-name">bash</span> - Execute a bash command in the current working directory. Returns stdout and stderr. Optionally provide a timeout in seconds.</div><div class="tool-item"><span class="tool-item-name">edit</span> - Edit a file by replacing exact text. The oldText must match exactly (including whitespace). Use this for precise, surgical edits.</div><div class="tool-item"><span class="tool-item-name">write</span> - Write content to a file. Creates the file if it doesn&#039;t exist, overwrites if it does. Automatically creates parent directories.</div>
            </div>
        </div>

        <div class="messages">
            <div class="user-message">many people are reporting that backup folder selection is not reflecting immediately in the backup queue, like if I deselected a folder or selected one then it should impact any running sync somehow, so that we don&#039;t upload stale files. Please prepare a plan for fixing this.</div><div class="assistant-text">I&#039;ll analyze the backup folder selection and sync system to understand how they interact and prepare a plan for fixing the stale file upload issue.<br><br>Let me first explore the relevant code:</div><div class="tool-execution" style="background-color: rgb(40, 50, 40)"><div class="tool-command">$ find /Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib -type f -name &quot;*.dart&quot; | xargs grep -l -i &quot;backup&quot; | head -20</div><div class="tool-output expandable" onclick="this.classList.toggle('expanded')"><div class="output-preview"><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_fr.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_et.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_ko.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_he.dart</div><div class="expand-hint">... (15 more lines) - click to expand</div></div><div class="output-full"><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_fr.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_et.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_ko.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_he.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_eu.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_gu.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_el.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_hi.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_ca.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_ro.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_bg.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_id.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_af.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_ti.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_da.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_lv.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_no.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_fa.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_vi.dart</div></div></div></div><div class="tool-execution" style="background-color: rgb(40, 50, 40)"><div class="tool-command">$ find /Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib -type f -name &quot;*.dart&quot; | xargs grep -l -i &quot;folder.*select\|device.*folder&quot; | head -20</div><div class="tool-output expandable" onclick="this.classList.toggle('expanded')"><div class="output-preview"><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_fr.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_et.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_ko.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_he.dart</div><div class="expand-hint">... (15 more lines) - click to expand</div></div><div class="output-full"><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_fr.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_et.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_ko.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_he.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_eu.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_gu.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_el.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_hi.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_ca.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_ro.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_bg.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_id.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_af.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_ti.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_da.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_lv.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_no.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_fa.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_vi.dart</div></div></div></div><div class="tool-execution" style="background-color: rgb(40, 50, 40)"><div class="tool-command">$ find /Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib -type f -name &quot;*.dart&quot; -name &quot;*sync*&quot; | head -20</div><div class="tool-output expandable" onclick="this.classList.toggle('expanded')"><div class="output-preview"><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/settings/pending_sync/pending_sync_info_screen.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/common/popup_item_async.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/events/sync_status_update_event.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/events/smart_album_syncing_event.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/events/diff_sync_complete_event.dart</div><div class="expand-hint">... (4 more lines) - click to expand</div></div><div class="output-full"><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/settings/pending_sync/pending_sync_info_screen.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/common/popup_item_async.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/events/sync_status_update_event.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/events/smart_album_syncing_event.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/events/diff_sync_complete_event.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/services/sync/remote_sync_service.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/services/sync/trash_sync_service.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/services/sync/local_sync_service.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/services/sync/sync_service.dart</div></div></div></div><div class="tool-execution" style="background-color: rgb(40, 50, 40)"><div class="tool-command">$ ls -la /Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/services/</div><div class="tool-output expandable" onclick="this.classList.toggle('expanded')"><div class="output-preview"><div>total 1120</div><div>drwxr-xr-x  44 prateeksunal  staff   1408 Nov 27 00:34 .</div><div>drwxr-xr-x  24 prateeksunal  staff    768 Nov 27 00:34 ..</div><div>-rw-r--r--   1 prateeksunal  staff   6148 Oct 20 12:39 .DS_Store</div><div>drwxr-xr-x   5 prateeksunal  staff    160 Nov 25 08:10 account</div><div class="expand-hint">... (40 more lines) - click to expand</div></div><div class="output-full"><div>total 1120</div><div>drwxr-xr-x  44 prateeksunal  staff   1408 Nov 27 00:34 .</div><div>drwxr-xr-x  24 prateeksunal  staff    768 Nov 27 00:34 ..</div><div>-rw-r--r--   1 prateeksunal  staff   6148 Oct 20 12:39 .DS_Store</div><div>drwxr-xr-x   5 prateeksunal  staff    160 Nov 25 08:10 account</div><div>-rw-r--r--   1 prateeksunal  staff  14649 Nov 25 08:10 album_home_widget_service.dart</div><div>-rw-r--r--   1 prateeksunal  staff   1348 Jul 11 12:08 app_lifecycle_service.dart</div><div>-rw-r--r--   1 prateeksunal  staff  75532 Nov 27 00:34 collections_service.dart</div><div>-rw-r--r--   1 prateeksunal  staff  11114 Sep 16 23:38 date_parse_service.dart</div><div>-rw-r--r--   1 prateeksunal  staff   4663 Sep  4 21:25 deduplication_service.dart</div><div>-rw-r--r--   1 prateeksunal  staff   8486 Aug 12 13:11 entity_service.dart</div><div>drwxr-xr-x   4 prateeksunal  staff    128 Nov 25 08:10 faces_timeline</div><div>-rw-r--r--   1 prateeksunal  staff   9617 Jul 11 12:08 favorites_service.dart</div><div>-rw-r--r--   1 prateeksunal  staff   7391 Jul 11 12:08 file_magic_service.dart</div><div>drwxr-xr-x   4 prateeksunal  staff    128 Oct 16 16:24 filedata</div><div>-rw-r--r--   1 prateeksunal  staff   9017 Sep  4 21:25 files_service.dart</div><div>drwxr-xr-x  10 prateeksunal  staff    320 Jul 11 12:08 filter</div><div>-rw-r--r--   1 prateeksunal  staff   9612 Sep  4 21:25 hidden_service.dart</div><div>-rw-r--r--   1 prateeksunal  staff  20328 Nov 25 08:10 home_widget_service.dart</div><div>-rw-r--r--   1 prateeksunal  staff   5063 Jul 11 12:08 ignored_files_service.dart</div><div>-rw-r--r--   1 prateeksunal  staff   1656 Sep 17 01:45 isolated_ffmpeg_service.dart</div><div>-rw-r--r--   1 prateeksunal  staff    266 Sep  4 21:25 language_service.dart</div><div>-rw-r--r--   1 prateeksunal  staff   3639 Aug 19 18:26 local_authentication_service.dart</div><div>-rw-r--r--   1 prateeksunal  staff   8338 Jul 11 12:08 local_file_update_service.dart</div><div>-rw-r--r--   1 prateeksunal  staff  14619 Jul 11 12:08 location_service.dart</div><div>drwxr-xr-x  16 prateeksunal  staff    512 Nov  5 12:48 machine_learning</div><div>-rw-r--r--   1 prateeksunal  staff  13539 Sep 16 23:38 magic_cache_service.dart</div><div>-rw-r--r--   1 prateeksunal  staff  26780 Nov 25 08:10 memories_cache_service.dart</div><div>-rw-r--r--   1 prateeksunal  staff  10885 Nov  5 12:48 memory_home_widget_service.dart</div><div>-rw-r--r--   1 prateeksunal  staff   9133 Jul 11 12:08 notification_service.dart</div><div>-rw-r--r--   1 prateeksunal  staff  12216 Nov  5 12:48 people_home_widget_service.dart</div><div>drwxr-xr-x   3 prateeksunal  staff     96 Jul 11 12:08 permission</div><div>-rw-r--r--   1 prateeksunal  staff   3486 Jul 11 12:08 push_service.dart</div><div>-rw-r--r--   1 prateeksunal  staff   4942 Jul 11 12:08 remote_assets_service.dart</div><div>-rw-r--r--   1 prateeksunal  staff  54550 Nov 25 08:10 search_service.dart</div><div>-rw-r--r--   1 prateeksunal  staff   8164 Nov 25 08:10 smart_albums_service.dart</div><div>-rw-r--r--   1 prateeksunal  staff  83096 Nov 25 08:10 smart_memories_service.dart</div><div>-rw-r--r--   1 prateeksunal  staff   1449 Jul 11 12:08 storage_bonus_service.dart</div><div>drwxr-xr-x   8 prateeksunal  staff    256 Nov 24 14:12 sync</div><div>-rw-r--r--   1 prateeksunal  staff    972 Sep 16 23:38 text_embeddings_cache_service.dart</div><div>-rw-r--r--   1 prateeksunal  staff   6344 Nov 25 08:10 update_service.dart</div><div>-rw-r--r--   1 prateeksunal  staff   7924 Nov 25 08:10 video_memory_service.dart</div><div>-rw-r--r--@  1 prateeksunal  staff  41631 Oct 31 15:58 video_preview_service.dart</div><div>-rw-r--r--   1 prateeksunal  staff   1578 Jul 11 12:08 wake_lock_service.dart</div><div>drwxr-xr-x   9 prateeksunal  staff    288 Nov 25 08:10 wrapped</div></div></div></div><div class="tool-execution" style="background-color: rgb(40, 50, 40)"><div class="tool-header"><span class="tool-name">read</span> <span class="tool-path">~/dev/enteio/ente/mobile/apps/photos/lib/services/sync/sync_service.dart</span></div><div class="tool-output expandable" onclick="this.classList.toggle('expanded')"><div class="output-preview"><div>import &#039;dart:async&#039;;</div><div>import &#039;dart:io&#039;;</div><div></div><div>import &#039;package:connectivity_plus/connectivity_plus.dart&#039;;</div><div>import &#039;package:dio/dio.dart&#039;;</div><div>import &#039;package:logging/logging.dart&#039;;</div><div>import &#039;package:photo_manager/photo_manager.dart&#039;;</div><div>import &#039;package:photos/core/configuration.dart&#039;;</div><div>import &#039;package:photos/core/constants.dart&#039;;</div><div>import &#039;package:photos/core/errors.dart&#039;;</div><div class="expand-hint">... (223 more lines) - click to expand</div></div><div class="output-full"><div>import &#039;dart:async&#039;;</div><div>import &#039;dart:io&#039;;</div><div></div><div>import &#039;package:connectivity_plus/connectivity_plus.dart&#039;;</div><div>import &#039;package:dio/dio.dart&#039;;</div><div>import &#039;package:logging/logging.dart&#039;;</div><div>import &#039;package:photo_manager/photo_manager.dart&#039;;</div><div>import &#039;package:photos/core/configuration.dart&#039;;</div><div>import &#039;package:photos/core/constants.dart&#039;;</div><div>import &#039;package:photos/core/errors.dart&#039;;</div><div>import &#039;package:photos/core/event_bus.dart&#039;;</div><div>import &#039;package:photos/events/subscription_purchased_event.dart&#039;;</div><div>import &#039;package:photos/events/sync_status_update_event.dart&#039;;</div><div>import &#039;package:photos/events/trigger_logout_event.dart&#039;;</div><div>import &quot;package:photos/main.dart&quot;;</div><div>import &#039;package:photos/models/file/file_type.dart&#039;;</div><div>import &quot;package:photos/service_locator.dart&quot;;</div><div>import &quot;package:photos/services/language_service.dart&quot;;</div><div>import &#039;package:photos/services/notification_service.dart&#039;;</div><div>import &#039;package:photos/services/sync/local_sync_service.dart&#039;;</div><div>import &#039;package:photos/services/sync/remote_sync_service.dart&#039;;</div><div>import &#039;package:photos/utils/file_uploader.dart&#039;;</div><div>import &#039;package:shared_preferences/shared_preferences.dart&#039;;</div><div></div><div>class SyncService {</div><div>  final _logger = Logger(&quot;SyncService&quot;);</div><div>  final _localSyncService = LocalSyncService.instance;</div><div>  final _remoteSyncService = RemoteSyncService.instance;</div><div>  final _uploader = FileUploader.instance;</div><div>  bool _syncStopRequested = false;</div><div>  Completer&lt;bool&gt;? _existingSync;</div><div>  late SharedPreferences _prefs;</div><div>  SyncStatusUpdate? _lastSyncStatusEvent;</div><div></div><div>  static const kLastStorageLimitExceededNotificationPushTime =</div><div>      &quot;last_storage_limit_exceeded_notification_push_time&quot;;</div><div></div><div>  SyncService._privateConstructor() {</div><div>    Bus.instance.on&lt;SubscriptionPurchasedEvent&gt;().listen((event) {</div><div>      _uploader.clearQueue(SilentlyCancelUploadsError());</div><div>      sync();</div><div>    });</div><div></div><div>    Connectivity()</div><div>        .onConnectivityChanged</div><div>        .listen((List&lt;ConnectivityResult&gt; result) {</div><div>      _logger.info(&quot;Connectivity change detected &quot; + result.toString());</div><div>      if (Configuration.instance.hasConfiguredAccount()) {</div><div>        sync();</div><div>      }</div><div>    });</div><div></div><div>    Bus.instance.on&lt;SyncStatusUpdate&gt;().listen((event) {</div><div>      _logger.info(&quot;Sync status received &quot; + event.toString());</div><div>      _lastSyncStatusEvent = event;</div><div>    });</div><div>  }</div><div></div><div>  static final SyncService instance = SyncService._privateConstructor();</div><div></div><div>  Future&lt;void&gt; init(SharedPreferences preferences) async {</div><div>    _prefs = preferences;</div><div>    if (Platform.isIOS) {</div><div>      _logger.info(&quot;Clearing file cache&quot;);</div><div>      await PhotoManager.clearFileCache();</div><div>      _logger.info(&quot;Cleared file cache&quot;);</div><div>    }</div><div>  }</div><div></div><div>  // Note: Do not use this future for anything except log out.</div><div>  // This is prone to bugs due to any potential race conditions</div><div>  Future&lt;bool&gt; existingSync() async {</div><div>    return _existingSync?.future ?? Future.value(true);</div><div>  }</div><div></div><div>  Future&lt;bool&gt; sync() async {</div><div>    _syncStopRequested = false;</div><div>    if (_existingSync != null) {</div><div>      _logger.warning(&quot;Sync already in progress, skipping.&quot;);</div><div>      return _existingSync!.future;</div><div>    }</div><div>    _existingSync = Completer&lt;bool&gt;();</div><div>    bool successful = false;</div><div>    try {</div><div>      await _doSync();</div><div>      if (_lastSyncStatusEvent != null &amp;&amp;</div><div>          _lastSyncStatusEvent!.status !=</div><div>              SyncStatus.completedFirstGalleryImport &amp;&amp;</div><div>          _lastSyncStatusEvent!.status != SyncStatus.completedBackup) {</div><div>        Bus.instance.fire(SyncStatusUpdate(SyncStatus.completedBackup));</div><div>      }</div><div>      successful = true;</div><div>    } on WiFiUnavailableError {</div><div>      _logger.warning(&quot;Not uploading over mobile data&quot;);</div><div>      Bus.instance.fire(</div><div>        SyncStatusUpdate(SyncStatus.paused, reason: &quot;Waiting for WiFi...&quot;),</div><div>      );</div><div>    } on SyncStopRequestedError {</div><div>      _syncStopRequested = false;</div><div>      Bus.instance.fire(</div><div>        SyncStatusUpdate(SyncStatus.completedBackup, wasStopped: true),</div><div>      );</div><div>    } on NoActiveSubscriptionError {</div><div>      Bus.instance.fire(</div><div>        SyncStatusUpdate(</div><div>          SyncStatus.error,</div><div>          error: NoActiveSubscriptionError(),</div><div>        ),</div><div>      );</div><div>    } on StorageLimitExceededError {</div><div>      _showStorageLimitExceededNotification();</div><div>      Bus.instance.fire(</div><div>        SyncStatusUpdate(</div><div>          SyncStatus.error,</div><div>          error: StorageLimitExceededError(),</div><div>        ),</div><div>      );</div><div>    } on UnauthorizedError {</div><div>      _logger.info(&quot;Logging user out&quot;);</div><div>      Bus.instance.fire(TriggerLogoutEvent());</div><div>    } on NoMediaLocationAccessError {</div><div>      _logger.severe(&quot;Not uploading due to no media location access&quot;);</div><div>      Bus.instance.fire(</div><div>        SyncStatusUpdate(</div><div>          SyncStatus.error,</div><div>          error: NoMediaLocationAccessError(),</div><div>        ),</div><div>      );</div><div>    } catch (e) {</div><div>      if (e is DioException) {</div><div>        if (e.type == DioExceptionType.connectionTimeout ||</div><div>            e.type == DioExceptionType.sendTimeout ||</div><div>            e.type == DioExceptionType.receiveTimeout ||</div><div>            e.type == DioExceptionType.unknown) {</div><div>          Bus.instance.fire(</div><div>            SyncStatusUpdate(</div><div>              SyncStatus.paused,</div><div>              reason: &quot;Waiting for network...&quot;,</div><div>            ),</div><div>          );</div><div>          _logger.severe(&quot;unable to connect&quot;, e, StackTrace.current);</div><div>          return false;</div><div>        }</div><div>      }</div><div>      _logger.severe(&quot;backup failed&quot;, e, StackTrace.current);</div><div>      Bus.instance.fire(SyncStatusUpdate(SyncStatus.error));</div><div>      rethrow;</div><div>    } finally {</div><div>      _existingSync?.complete(successful);</div><div>      _existingSync = null;</div><div>      _lastSyncStatusEvent = null;</div><div>      _logger.info(&quot;Syncing completed&quot;);</div><div>    }</div><div>    return successful;</div><div>  }</div><div></div><div>  void stopSync() {</div><div>    _logger.info(&quot;Sync stop requested&quot;);</div><div>    _syncStopRequested = true;</div><div>  }</div><div></div><div>  bool shouldStopSync() {</div><div>    return _syncStopRequested;</div><div>  }</div><div></div><div>  bool isSyncInProgress() {</div><div>    return _existingSync != null;</div><div>  }</div><div></div><div>  SyncStatusUpdate? getLastSyncStatusEvent() {</div><div>    return _lastSyncStatusEvent;</div><div>  }</div><div></div><div>  Future&lt;void&gt; onPermissionGranted() async {</div><div>    _doSync().ignore();</div><div>  }</div><div></div><div>  void onDeviceCollectionSet(Set&lt;int&gt; collectionIDs) {</div><div>    _uploader.removeFromQueueWhere(</div><div>      (file) {</div><div>        return !collectionIDs.contains(file.collectionID);</div><div>      },</div><div>      UserCancelledUploadError(),</div><div>    );</div><div>  }</div><div></div><div>  void onVideoBackupPaused() {</div><div>    _uploader.removeFromQueueWhere(</div><div>      (file) {</div><div>        return file.fileType == FileType.video;</div><div>      },</div><div>      UserCancelledUploadError(),</div><div>    );</div><div>  }</div><div></div><div>  Future&lt;void&gt; _doSync() async {</div><div>    _logger.info(&quot;[SYNC] Starting local sync&quot;);</div><div>    await _localSyncService.sync();</div><div></div><div>    if (_localSyncService.hasCompletedFirstImport()) {</div><div>      _logger.info(&quot;[SYNC] Starting remote sync&quot;);</div><div>      await _remoteSyncService.sync();</div><div></div><div>      final shouldSync = await _localSyncService.syncAll();</div><div>      if (shouldSync) {</div><div>        _logger.info(&quot;[SYNC] Starting second remote sync&quot;);</div><div>        await _remoteSyncService.sync();</div><div>      }</div><div></div><div>      if (!isProcessBg) {</div><div>        await smartAlbumsService.syncSmartAlbums();</div><div>      }</div><div>    } else {</div><div>      _logger.info(&quot;[SYNC] First import not completed, skipping remote&quot;);</div><div>    }</div><div>  }</div><div></div><div>  void _showStorageLimitExceededNotification() async {</div><div>    final lastNotificationShownTime =</div><div>        _prefs.getInt(kLastStorageLimitExceededNotificationPushTime) ?? 0;</div><div>    final now = DateTime.now().microsecondsSinceEpoch;</div><div>    if ((now - lastNotificationShownTime) &gt; microSecondsInDay) {</div><div>      await _prefs.setInt(kLastStorageLimitExceededNotificationPushTime, now);</div><div>      final s = await LanguageService.locals;</div><div>      // ignore: unawaited_futures</div><div>      NotificationService.instance.showNotification(</div><div>        s.storageLimitExceeded,</div><div>        s.sorryWeHadToPauseYourBackups,</div><div>      );</div><div>    }</div><div>  }</div><div>}</div><div></div></div></div></div><div class="tool-execution" style="background-color: rgb(40, 50, 40)"><div class="tool-command">$ ls -la /Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/services/sync/</div><div class="tool-output expandable" onclick="this.classList.toggle('expanded')"><div class="output-preview"><div>total 184</div><div>drwxr-xr-x   8 prateeksunal  staff    256 Nov 24 14:12 .</div><div>drwxr-xr-x  44 prateeksunal  staff   1408 Nov 27 00:34 ..</div><div>-rw-r--r--   1 prateeksunal  staff   7815 Sep  4 21:25 diff_fetcher.dart</div><div>drwxr-xr-x   5 prateeksunal  staff    160 Nov  5 12:48 import</div><div class="expand-hint">... (4 more lines) - click to expand</div></div><div class="output-full"><div>total 184</div><div>drwxr-xr-x   8 prateeksunal  staff    256 Nov 24 14:12 .</div><div>drwxr-xr-x  44 prateeksunal  staff   1408 Nov 27 00:34 ..</div><div>-rw-r--r--   1 prateeksunal  staff   7815 Sep  4 21:25 diff_fetcher.dart</div><div>drwxr-xr-x   5 prateeksunal  staff    160 Nov  5 12:48 import</div><div>-rw-r--r--   1 prateeksunal  staff  13583 Nov 24 14:12 local_sync_service.dart</div><div>-rw-r--r--   1 prateeksunal  staff  46268 Nov 24 14:12 remote_sync_service.dart</div><div>-rw-r--r--   1 prateeksunal  staff   7417 Nov 24 14:12 sync_service.dart</div><div>-rw-r--r--   1 prateeksunal  staff  10971 Jul 11 12:08 trash_sync_service.dart</div></div></div></div><div class="tool-execution" style="background-color: rgb(40, 50, 40)"><div class="tool-header"><span class="tool-name">read</span> <span class="tool-path">~/dev/enteio/ente/mobile/apps/photos/lib/services/sync/local_sync_service.dart</span></div><div class="tool-output expandable" onclick="this.classList.toggle('expanded')"><div class="output-preview"><div>import &#039;dart:async&#039;;</div><div>import &#039;dart:io&#039;;</div><div></div><div>import &#039;package:flutter/foundation.dart&#039;;</div><div>import &#039;package:logging/logging.dart&#039;;</div><div>import &#039;package:photo_manager/photo_manager.dart&#039;;</div><div>import &quot;package:photos/core/cache/lru_map.dart&quot;;</div><div>import &#039;package:photos/core/configuration.dart&#039;;</div><div>import &quot;package:photos/core/errors.dart&quot;;</div><div>import &#039;package:photos/core/event_bus.dart&#039;;</div><div class="expand-hint">... (374 more lines) - click to expand</div></div><div class="output-full"><div>import &#039;dart:async&#039;;</div><div>import &#039;dart:io&#039;;</div><div></div><div>import &#039;package:flutter/foundation.dart&#039;;</div><div>import &#039;package:logging/logging.dart&#039;;</div><div>import &#039;package:photo_manager/photo_manager.dart&#039;;</div><div>import &quot;package:photos/core/cache/lru_map.dart&quot;;</div><div>import &#039;package:photos/core/configuration.dart&#039;;</div><div>import &quot;package:photos/core/errors.dart&quot;;</div><div>import &#039;package:photos/core/event_bus.dart&#039;;</div><div>import &quot;package:photos/db/common/conflict_algo.dart&quot;;</div><div>import &#039;package:photos/db/device_files_db.dart&#039;;</div><div>import &#039;package:photos/db/file_updation_db.dart&#039;;</div><div>import &#039;package:photos/db/files_db.dart&#039;;</div><div>import &#039;package:photos/events/backup_folders_updated_event.dart&#039;;</div><div>import &#039;package:photos/events/local_photos_updated_event.dart&#039;;</div><div>import &quot;package:photos/events/permission_granted_event.dart&quot;;</div><div>import &#039;package:photos/events/sync_status_update_event.dart&#039;;</div><div>import &#039;package:photos/extensions/stop_watch.dart&#039;;</div><div>import &#039;package:photos/models/file/file.dart&#039;;</div><div>import &quot;package:photos/models/ignored_file.dart&quot;;</div><div>import &quot;package:photos/service_locator.dart&quot;;</div><div>import &#039;package:photos/services/app_lifecycle_service.dart&#039;;</div><div>import &quot;package:photos/services/ignored_files_service.dart&quot;;</div><div>import &quot;package:photos/services/sync/import/diff.dart&quot;;</div><div>import &quot;package:photos/services/sync/import/local_assets.dart&quot;;</div><div>import &quot;package:photos/services/sync/import/model.dart&quot;;</div><div>import &quot;package:photos/utils/standalone/debouncer.dart&quot;;</div><div>import &#039;package:shared_preferences/shared_preferences.dart&#039;;</div><div>import &#039;package:synchronized/synchronized.dart&#039;;</div><div>import &#039;package:tuple/tuple.dart&#039;;</div><div></div><div>// This map is used to track if a iOS origin file is being fetched for uploading</div><div>// or ML processing. In such cases, we want to ignore these files if they come in response</div><div>// from the local sync service. When a file is download</div><div>final LRUMap&lt;String, bool&gt; trackOriginFetchForUploadOrML = LRUMap(200);</div><div></div><div>class LocalSyncService {</div><div>  final _logger = Logger(&quot;LocalSyncService&quot;);</div><div>  final _db = FilesDB.instance;</div><div>  late SharedPreferences _prefs;</div><div>  Completer&lt;void&gt;? _existingSync;</div><div>  late Debouncer _changeCallbackDebouncer;</div><div>  final Lock _lock = Lock();</div><div></div><div>  static const kDbUpdationTimeKey = &quot;db_updation_time&quot;;</div><div>  static const kHasCompletedFirstImportKey = &quot;has_completed_firstImport&quot;;</div><div></div><div>  LocalSyncService._privateConstructor();</div><div></div><div>  static final LocalSyncService instance =</div><div>      LocalSyncService._privateConstructor();</div><div></div><div>  Future&lt;void&gt; init(SharedPreferences preferences) async {</div><div>    _prefs = preferences;</div><div>    if (!AppLifecycleService.instance.isForeground) {</div><div>      await PhotoManager.setIgnorePermissionCheck(true);</div><div>    }</div><div>    if (permissionService.hasGrantedPermissions()) {</div><div>      _registerChangeCallback();</div><div>    } else {</div><div>      Bus.instance.on&lt;PermissionGrantedEvent&gt;().listen((event) async {</div><div>        _registerChangeCallback();</div><div>      });</div><div>    }</div><div>  }</div><div></div><div>  Future&lt;void&gt; sync() async {</div><div>    if (!permissionService.hasGrantedPermissions()) {</div><div>      _logger.info(&quot;Skipping local sync since permission has not been granted&quot;);</div><div>      return;</div><div>    }</div><div>    if (Platform.isAndroid &amp;&amp; AppLifecycleService.instance.isForeground) {</div><div>      final permissionState =</div><div>          await permissionService.requestPhotoMangerPermissions();</div><div>      if (permissionState != PermissionState.authorized) {</div><div>        _logger.severe(</div><div>          &quot;sync requested with invalid permission&quot;,</div><div>          permissionState.toString(),</div><div>        );</div><div>        return;</div><div>      }</div><div>    }</div><div>    if (_existingSync != null) {</div><div>      _logger.warning(&quot;Sync already in progress, skipping.&quot;);</div><div>      return _existingSync!.future;</div><div>    }</div><div>    _existingSync = Completer&lt;void&gt;();</div><div>    final int ownerID = Configuration.instance.getUserID()!;</div><div></div><div>    // We use a lock to prevent synchronisation to occur while it is downloading</div><div>    // as this introduces wrong entry in FilesDB due to race condition</div><div>    // This is a fix for https://github.com/ente-io/ente/issues/4296</div><div>    await _lock.synchronized(() async {</div><div>      final existingLocalFileIDs = await _db.getExistingLocalFileIDs(ownerID);</div><div>      _logger.info(&quot;${existingLocalFileIDs.length} localIDs were discovered&quot;);</div><div></div><div>      final syncStartTime = DateTime.now().microsecondsSinceEpoch;</div><div>      final lastDBUpdationTime = _prefs.getInt(kDbUpdationTimeKey) ?? 0;</div><div>      final startTime = DateTime.now().microsecondsSinceEpoch;</div><div>      if (lastDBUpdationTime != 0) {</div><div>        await _loadAndStoreDiff(</div><div>          existingLocalFileIDs,</div><div>          fromTime: lastDBUpdationTime,</div><div>          toTime: syncStartTime,</div><div>        );</div><div>      } else {</div><div>        // Load from 0 - 01.01.2010</div><div>        Bus.instance</div><div>            .fire(SyncStatusUpdate(SyncStatus.startedFirstGalleryImport));</div><div>        var startTime = 0;</div><div>        var toYear = 2010;</div><div>        var toTime = DateTime(toYear).microsecondsSinceEpoch;</div><div>        while (toTime &lt; syncStartTime) {</div><div>          await _loadAndStoreDiff(</div><div>            existingLocalFileIDs,</div><div>            fromTime: startTime,</div><div>            toTime: toTime,</div><div>          );</div><div>          startTime = toTime;</div><div>          toYear++;</div><div>          toTime = DateTime(toYear).microsecondsSinceEpoch;</div><div>        }</div><div>        await _loadAndStoreDiff(</div><div>          existingLocalFileIDs,</div><div>          fromTime: startTime,</div><div>          toTime: syncStartTime,</div><div>        );</div><div>      }</div><div>      if (!hasCompletedFirstImport()) {</div><div>        await _prefs.setBool(kHasCompletedFirstImportKey, true);</div><div>        await _refreshDeviceFolderCountAndCover(isFirstSync: true);</div><div>        _logger.info(&quot;first gallery import finished&quot;);</div><div>        Bus.instance</div><div>            .fire(SyncStatusUpdate(SyncStatus.completedFirstGalleryImport));</div><div>      }</div><div>      final endTime = DateTime.now().microsecondsSinceEpoch;</div><div>      final duration = Duration(microseconds: endTime - startTime);</div><div>      _logger.info(&quot;Load took &quot; + duration.inMilliseconds.toString() + &quot;ms&quot;);</div><div>    });</div><div></div><div>    _existingSync?.complete();</div><div>    _existingSync = null;</div><div>  }</div><div></div><div>  Future&lt;bool&gt; _refreshDeviceFolderCountAndCover({</div><div>    bool isFirstSync = false,</div><div>  }) async {</div><div>    final List&lt;Tuple2&lt;AssetPathEntity, String&gt;&gt; result =</div><div>        await getDeviceFolderWithCountAndCoverID();</div><div>    final bool hasUpdated = await _db.updateDeviceCoverWithCount(</div><div>      result,</div><div>      shouldBackup: Configuration.instance.hasSelectedAllFoldersForBackup(),</div><div>    );</div><div>    // do not fire UI update event during first sync. Otherwise the next screen</div><div>    // to shop the backup folder is skipped</div><div>    if (hasUpdated &amp;&amp; !isFirstSync) {</div><div>      Bus.instance.fire(BackupFoldersUpdatedEvent());</div><div>    }</div><div>    return hasUpdated;</div><div>  }</div><div></div><div>  Future&lt;bool&gt; syncAll() async {</div><div>    if (!Configuration.instance.isLoggedIn()) {</div><div>      _logger.warning(&quot;syncCall called when user is not logged in&quot;);</div><div>      return false;</div><div>    }</div><div>    final stopwatch = EnteWatch(&quot;localSyncAll&quot;)..start();</div><div></div><div>    final localAssets = await getAllLocalAssets();</div><div>    _logger.info(</div><div>      &quot;Loading allLocalAssets ${localAssets.length} took ${stopwatch.elapsedMilliseconds}ms &quot;,</div><div>    );</div><div>    await _refreshDeviceFolderCountAndCover();</div><div>    _logger.info(</div><div>      &quot;refreshDeviceFolderCountAndCover + allLocalAssets took ${stopwatch.elapsedMilliseconds}ms &quot;,</div><div>    );</div><div>    final int ownerID = Configuration.instance.getUserID()!;</div><div>    final existingLocalFileIDs = await _db.getExistingLocalFileIDs(ownerID);</div><div>    final Map&lt;String, Set&lt;String&gt;&gt; pathToLocalIDs =</div><div>        await _db.getDevicePathIDToLocalIDMap();</div><div></div><div>    final localDiffResult = await getDiffFromExistingImport(</div><div>      localAssets,</div><div>      existingLocalFileIDs,</div><div>      pathToLocalIDs,</div><div>    );</div><div>    bool hasAnyMappingChanged = false;</div><div>    if (localDiffResult.newPathToLocalIDs?.isNotEmpty ?? false) {</div><div>      await _db</div><div>          .insertPathIDToLocalIDMapping(localDiffResult.newPathToLocalIDs!);</div><div>      hasAnyMappingChanged = true;</div><div>    }</div><div>    if (localDiffResult.deletePathToLocalIDs?.isNotEmpty ?? false) {</div><div>      await _db</div><div>          .deletePathIDToLocalIDMapping(localDiffResult.deletePathToLocalIDs!);</div><div>      hasAnyMappingChanged = true;</div><div>    }</div><div>    final bool hasUnsyncedFiles =</div><div>        localDiffResult.uniqueLocalFiles?.isNotEmpty ?? false;</div><div>    if (hasUnsyncedFiles) {</div><div>      await _db.insertMultiple(</div><div>        localDiffResult.uniqueLocalFiles!,</div><div>        conflictAlgorithm: SqliteAsyncConflictAlgorithm.ignore,</div><div>      );</div><div>      _logger.info(</div><div>        &quot;Inserted ${localDiffResult.uniqueLocalFiles?.length} &quot;</div><div>        &quot;un-synced files&quot;,</div><div>      );</div><div>    }</div><div>    debugPrint(</div><div>      &quot;syncAll: mappingChange : $hasAnyMappingChanged, &quot;</div><div>      &quot;unSyncedFiles: $hasUnsyncedFiles&quot;,</div><div>    );</div><div>    if (hasAnyMappingChanged || hasUnsyncedFiles) {</div><div>      Bus.instance.fire(</div><div>        LocalPhotosUpdatedEvent(</div><div>          localDiffResult.uniqueLocalFiles ?? [],</div><div>          source: &quot;syncAllChange&quot;,</div><div>        ),</div><div>      );</div><div>    }</div><div>    _logger.info(&quot;syncAll took ${stopwatch.elapsed.inMilliseconds}ms &quot;);</div><div>    return hasUnsyncedFiles;</div><div>  }</div><div></div><div>  Future&lt;void&gt; ignoreUpload(EnteFile file, InvalidFileError error) async {</div><div>    if (file.localID == null ||</div><div>        file.deviceFolder == null ||</div><div>        file.title == null) {</div><div>      _logger.warning(&#039;Invalid file received for ignoring: $file&#039;);</div><div>      return;</div><div>    }</div><div>    if (Platform.isIOS &amp;&amp; error.reason == InvalidReason.sourceFileMissing) {</div><div>      // ignoreSourceFileMissing error on iOS as the file fetch from iCloud might have failed,</div><div>      // but the file might be available later</div><div>      return;</div><div>    }</div><div>    final ignored = IgnoredFile(</div><div>      file.localID,</div><div>      file.title,</div><div>      file.deviceFolder,</div><div>      error.reason.name,</div><div>    );</div><div>    await IgnoredFilesService.instance.cacheAndInsert([ignored]);</div><div>  }</div><div></div><div>  Lock getLock() {</div><div>    return _lock;</div><div>  }</div><div></div><div>  bool hasCompletedFirstImport() {</div><div>    return _prefs.getBool(kHasCompletedFirstImportKey) ?? false;</div><div>  }</div><div></div><div>  // Warning: resetLocalSync should only be used for testing imported related</div><div>  // changes</div><div>  Future&lt;void&gt; resetLocalSync() async {</div><div>    assert(kDebugMode, &quot;only available in debug mode&quot;);</div><div>    await FilesDB.instance.deleteDB();</div><div>    for (var element in [</div><div>      kHasCompletedFirstImportKey,</div><div>      kDbUpdationTimeKey,</div><div>      &quot;has_synced_edit_time&quot;,</div><div>      &quot;has_selected_all_folders_for_backup&quot;,</div><div>    ]) {</div><div>      await _prefs.remove(element);</div><div>    }</div><div>  }</div><div></div><div>  Future&lt;void&gt; _loadAndStoreDiff(</div><div>    Set&lt;String&gt; existingLocalDs, {</div><div>    required int fromTime,</div><div>    required int toTime,</div><div>  }) async {</div><div>    final Tuple2&lt;List&lt;LocalPathAsset&gt;, List&lt;EnteFile&gt;&gt; result =</div><div>        await getLocalPathAssetsAndFiles(fromTime, toTime);</div><div></div><div>    final List&lt;EnteFile&gt; files = result.item2;</div><div>    if (files.isNotEmpty) {</div><div>      // Update the mapping for device path_id to local file id. Also, keep track</div><div>      // of newly discovered device paths</div><div>      await FilesDB.instance.insertLocalAssets(</div><div>        result.item1,</div><div>        shouldAutoBackup:</div><div>            Configuration.instance.hasSelectedAllFoldersForBackup(),</div><div>      );</div><div></div><div>      _logger.info(</div><div>        &quot;Loaded ${files.length} photos from &quot; +</div><div>            DateTime.fromMicrosecondsSinceEpoch(fromTime).toString() +</div><div>            &quot; to &quot; +</div><div>            DateTime.fromMicrosecondsSinceEpoch(toTime).toString(),</div><div>      );</div><div>      await _trackUpdatedFiles(files, existingLocalDs);</div><div>      // keep reference of all Files for firing LocalPhotosUpdatedEvent</div><div>      final List&lt;EnteFile&gt; allFiles = [];</div><div>      allFiles.addAll(files);</div><div>      // remove existing files and insert newly imported files in the table</div><div>      files.removeWhere((file) =&gt; existingLocalDs.contains(file.localID));</div><div>      await _db.insertMultiple(</div><div>        files,</div><div>        conflictAlgorithm: SqliteAsyncConflictAlgorithm.ignore,</div><div>      );</div><div>      _logger.info(&#039;Inserted ${files.length} out of ${allFiles.length} files&#039;);</div><div>      _checkAndFireLocalAssetUpdateEvent(allFiles, files.isNotEmpty);</div><div>    }</div><div>    await _prefs.setInt(kDbUpdationTimeKey, toTime);</div><div>  }</div><div></div><div>  void _checkAndFireLocalAssetUpdateEvent(</div><div>    List&lt;EnteFile&gt; allFiles,</div><div>    bool discoveredNewFiles,</div><div>  ) {</div><div>    if (allFiles.isEmpty) return;</div><div>    if (!discoveredNewFiles) {</div><div>      allFiles.removeWhere(</div><div>        (file) =&gt;</div><div>            trackOriginFetchForUploadOrML.get(file.localID ?? &#039;&#039;) ?? false,</div><div>      );</div><div>      if (allFiles.isEmpty) {</div><div>        _logger.info(&quot;skipping firing LocalPhotosUpdatedEvent as no new files&quot;);</div><div>        return;</div><div>      }</div><div>    }</div><div>    Bus.instance.fire(</div><div>      LocalPhotosUpdatedEvent(allFiles, source: &quot;loadedPhoto&quot;),</div><div>    );</div><div>  }</div><div></div><div>  Future&lt;void&gt; _trackUpdatedFiles(</div><div>    List&lt;EnteFile&gt; files,</div><div>    Set&lt;String&gt; existingLocalFileIDs,</div><div>  ) async {</div><div>    final List&lt;String&gt; updatedLocalIDs = files</div><div>        .where(</div><div>          (file) =&gt;</div><div>              file.localID != null &amp;&amp;</div><div>              existingLocalFileIDs.contains(file.localID),</div><div>        )</div><div>        .map((e) =&gt; e.localID!)</div><div>        .toList();</div><div></div><div>    if (updatedLocalIDs.isNotEmpty) {</div><div>      final int updateCount = updatedLocalIDs.length;</div><div>      updatedLocalIDs</div><div>          .removeWhere((x) =&gt; trackOriginFetchForUploadOrML.get(x) ?? false);</div><div>      _logger.info(</div><div>        &quot;track ${updatedLocalIDs.length}/ $updateCount files due to modification change&quot;,</div><div>      );</div><div>      if (updatedLocalIDs.isEmpty) {</div><div>        await FileUpdationDB.instance.insertMultiple(</div><div>          updatedLocalIDs,</div><div>          FileUpdationDB.modificationTimeUpdated,</div><div>        );</div><div>      }</div><div>    }</div><div>  }</div><div></div><div>  void _registerChangeCallback() {</div><div>    _changeCallbackDebouncer = Debouncer(const Duration(milliseconds: 500));</div><div>    // In case of iOS limit permission, this call back is fired immediately</div><div>    // after file selection dialog is dismissed.</div><div>    PhotoManager.addChangeCallback((value) async {</div><div>      _logger.info(&quot;Something changed on disk&quot;);</div><div>      _changeCallbackDebouncer.run(() async {</div><div>        unawaited(checkAndSync());</div><div>      });</div><div>    });</div><div>    PhotoManager.startChangeNotify();</div><div>  }</div><div></div><div>  Future&lt;void&gt; checkAndSync() async {</div><div>    if (_existingSync != null) {</div><div>      await _existingSync!.future;</div><div>    }</div><div>    if (permissionService.hasGrantedLimitedPermissions()) {</div><div>      unawaited(syncAll());</div><div>    } else {</div><div>      unawaited(sync().then((value) =&gt; _refreshDeviceFolderCountAndCover()));</div><div>    }</div><div>  }</div><div>}</div><div></div></div></div></div><div class="tool-execution" style="background-color: rgb(40, 50, 40)"><div class="tool-header"><span class="tool-name">read</span> <span class="tool-path">~/dev/enteio/ente/mobile/apps/photos/lib/services/sync/remote_sync_service.dart</span></div><div class="tool-output expandable" onclick="this.classList.toggle('expanded')"><div class="output-preview"><div>import &#039;dart:async&#039;;</div><div>import &#039;dart:io&#039;;</div><div>import &#039;dart:math&#039;;</div><div></div><div>import &#039;package:flutter/widgets.dart&#039;;</div><div>import &#039;package:logging/logging.dart&#039;;</div><div>import &#039;package:photos/core/configuration.dart&#039;;</div><div>import &#039;package:photos/core/errors.dart&#039;;</div><div>import &#039;package:photos/core/event_bus.dart&#039;;</div><div>import &#039;package:photos/db/device_files_db.dart&#039;;</div><div class="expand-hint">... (1201 more lines) - click to expand</div></div><div class="output-full"><div>import &#039;dart:async&#039;;</div><div>import &#039;dart:io&#039;;</div><div>import &#039;dart:math&#039;;</div><div></div><div>import &#039;package:flutter/widgets.dart&#039;;</div><div>import &#039;package:logging/logging.dart&#039;;</div><div>import &#039;package:photos/core/configuration.dart&#039;;</div><div>import &#039;package:photos/core/errors.dart&#039;;</div><div>import &#039;package:photos/core/event_bus.dart&#039;;</div><div>import &#039;package:photos/db/device_files_db.dart&#039;;</div><div>import &#039;package:photos/db/file_updation_db.dart&#039;;</div><div>import &#039;package:photos/db/files_db.dart&#039;;</div><div>import &#039;package:photos/events/backup_folders_updated_event.dart&#039;;</div><div>import &#039;package:photos/events/collection_updated_event.dart&#039;;</div><div>import &quot;package:photos/events/diff_sync_complete_event.dart&quot;;</div><div>import &#039;package:photos/events/files_updated_event.dart&#039;;</div><div>import &#039;package:photos/events/force_reload_home_gallery_event.dart&#039;;</div><div>import &#039;package:photos/events/local_photos_updated_event.dart&#039;;</div><div>import &#039;package:photos/events/sync_status_update_event.dart&#039;;</div><div>import &quot;package:photos/extensions/logger_extension.dart&quot;;</div><div>import &quot;package:photos/main.dart&quot; show isProcessBg;</div><div>import &#039;package:photos/models/device_collection.dart&#039;;</div><div>import &quot;package:photos/models/file/extensions/file_props.dart&quot;;</div><div>import &#039;package:photos/models/file/file.dart&#039;;</div><div>import &#039;package:photos/models/file/file_type.dart&#039;;</div><div>import &#039;package:photos/models/upload_strategy.dart&#039;;</div><div>import &quot;package:photos/service_locator.dart&quot;;</div><div>import &#039;package:photos/services/app_lifecycle_service.dart&#039;;</div><div>import &#039;package:photos/services/collections_service.dart&#039;;</div><div>import &#039;package:photos/services/ignored_files_service.dart&#039;;</div><div>import &quot;package:photos/services/language_service.dart&quot;;</div><div>import &#039;package:photos/services/local_file_update_service.dart&#039;;</div><div>import &quot;package:photos/services/notification_service.dart&quot;;</div><div>import &#039;package:photos/services/sync/diff_fetcher.dart&#039;;</div><div>import &#039;package:photos/services/sync/sync_service.dart&#039;;</div><div>import &#039;package:photos/utils/file_uploader.dart&#039;;</div><div>import &#039;package:photos/utils/file_util.dart&#039;;</div><div>import &#039;package:shared_preferences/shared_preferences.dart&#039;;</div><div></div><div>class RemoteSyncService {</div><div>  final _logger = Logger(&quot;RemoteSyncService&quot;);</div><div>  final _db = FilesDB.instance;</div><div>  final FileUploader _uploader = FileUploader.instance;</div><div>  final Configuration _config = Configuration.instance;</div><div>  final CollectionsService _collectionsService = CollectionsService.instance;</div><div>  final DiffFetcher _diffFetcher = DiffFetcher();</div><div>  final LocalFileUpdateService _localFileUpdateService =</div><div>      LocalFileUpdateService.instance;</div><div>  int _completedUploads = 0;</div><div>  int _ignoredUploads = 0;</div><div>  late SharedPreferences _prefs;</div><div>  Completer&lt;void&gt;? _existingSync;</div><div>  bool _isExistingSyncSilent = false;</div><div></div><div>  // _hasCleanupStaleEntry is used to track if we have already cleaned up</div><div>  // statle db entries in this sync session.</div><div>  bool _hasCleanupStaleEntry = false;</div><div></div><div>  static const kHasSyncedArchiveKey = &quot;has_synced_archive&quot;;</div><div>  /* This setting is used to maintain a list of local IDs for videos that the user has manually</div><div> marked for upload, even if the global video upload setting is currently disabled.</div><div> When the global video upload setting is disabled, we typically ignore all video uploads. However, for videos that have been added to this list, we</div><div> want to still allow them to be uploaded, despite the global setting being disabled.</div><div></div><div> This allows users to queue up videos for upload, and have them successfully upload</div><div> even if they later toggle the global video upload setting to disabled.</div><div>   */</div><div>  static const _ignoreBackUpSettingsForIDs_ = &quot;ignoreBackUpSettingsForIDs&quot;;</div><div>  final String _isFirstRemoteSyncDone = &quot;isFirstRemoteSyncDone&quot;;</div><div></div><div>  // 28 Sept, 2021 9:03:20 AM IST</div><div>  static const kArchiveFeatureReleaseTime = 1632800000000000;</div><div>  static const kHasSyncedEditTime = &quot;has_synced_edit_time&quot;;</div><div></div><div>  // 29 October, 2021 3:56:40 AM IST</div><div>  static const kEditTimeFeatureReleaseTime = 1635460000000000;</div><div></div><div>  static const kMaximumPermissibleUploadsInThrottledMode = 4;</div><div></div><div>  static final RemoteSyncService instance =</div><div>      RemoteSyncService._privateConstructor();</div><div></div><div>  RemoteSyncService._privateConstructor();</div><div></div><div>  void init(SharedPreferences preferences) {</div><div>    _prefs = preferences;</div><div></div><div>    Bus.instance.on&lt;LocalPhotosUpdatedEvent&gt;().listen((event) async {</div><div>      if (event.type == EventType.addedOrUpdated) {</div><div>        if (_existingSync == null) {</div><div>          // ignore: unawaited_futures</div><div>          sync();</div><div>        }</div><div>      }</div><div>    });</div><div>  }</div><div></div><div>  Future&lt;void&gt; sync({bool silently = false}) async {</div><div>    if (!_config.hasConfiguredAccount()) {</div><div>      _logger.info(&quot;Skipping remote sync since account is not configured&quot;);</div><div>      return;</div><div>    }</div><div>    if (_existingSync != null) {</div><div>      _logger.info(&quot;Remote sync already in progress, skipping&quot;);</div><div>      // if current sync is silent but request sync is non-silent (demands UI</div><div>      // updates), update the syncSilently flag</div><div>      if (_isExistingSyncSilent &amp;&amp; !silently) {</div><div>        _isExistingSyncSilent = false;</div><div>      }</div><div>      return _existingSync?.future;</div><div>    }</div><div>    _existingSync = Completer&lt;void&gt;();</div><div>    _isExistingSyncSilent = silently;</div><div>    _logger.info(</div><div>      &quot;Starting remote sync &quot; +</div><div>          (silently ? &quot;silently&quot; : &quot; with status updates&quot;),</div><div>    );</div><div></div><div>    try {</div><div>      // use flag to decide if we should start marking files for upload before</div><div>      // remote-sync is done. This is done to avoid adding existing files to</div><div>      // the same or different collection when user had already uploaded them</div><div>      // before.</div><div>      final bool hasSyncedBefore = _prefs.containsKey(_isFirstRemoteSyncDone);</div><div>      if (hasSyncedBefore) {</div><div>        await syncDeviceCollectionFilesForUpload();</div><div>      }</div><div>      await _pullDiff();</div><div>      await trashSyncService.syncTrash();</div><div>      if (!hasSyncedBefore) {</div><div>        await _prefs.setBool(_isFirstRemoteSyncDone, true);</div><div>        await syncDeviceCollectionFilesForUpload();</div><div>      }</div><div></div><div>      if (</div><div>          // We don&#039;t need syncFDStatus here if in background</div><div>          !isProcessBg) {</div><div>        fileDataService.syncFDStatus().ignore();</div><div>      }</div><div></div><div>      final filesToBeUploaded = await _getFilesToBeUploaded();</div><div>      final hasUploadedFiles = await _uploadFiles(filesToBeUploaded);</div><div>      if (filesToBeUploaded.isNotEmpty) {</div><div>        _logger.info(</div><div>            &quot;Files ${filesToBeUploaded.length} queued for upload, completed: &quot;</div><div>            &quot;$_completedUploads, ignored $_ignoredUploads&quot;);</div><div>      } else {</div><div>        _logger.info(&quot;No files to upload for this session&quot;);</div><div>      }</div><div>      if (hasUploadedFiles) {</div><div>        await _pullDiff();</div><div>        _existingSync?.complete();</div><div>        _existingSync = null;</div><div>        await syncDeviceCollectionFilesForUpload();</div><div>        final hasMoreFilesToBackup = (await _getFilesToBeUploaded()).isNotEmpty;</div><div>        _logger.info(&quot;hasMoreFilesToBackup?&quot; + hasMoreFilesToBackup.toString());</div><div>        if (hasMoreFilesToBackup) {</div><div>          // Skipping a resync to ensure that files that were ignored in this</div><div>          // session are not processed now</div><div>          await sync();</div><div>        } else {</div><div>          _logger.info(&quot;Fire backup completed event&quot;);</div><div>          Bus.instance.fire(SyncStatusUpdate(SyncStatus.completedBackup));</div><div>        }</div><div>      } else {</div><div>        // if filesToBeUploaded is empty, clear any stale files in the temp</div><div>        // directory</div><div>        if (filesToBeUploaded.isEmpty) {</div><div>          await _uploader.removeStaleFiles();</div><div>        }</div><div>        if (_ignoredUploads &gt; 0) {</div><div>          _logger.info(&quot;Ignored $_ignoredUploads files for upload, fire &quot;</div><div>              &quot;backup done&quot;);</div><div>          Bus.instance.fire(SyncStatusUpdate(SyncStatus.completedBackup));</div><div>        }</div><div>        _existingSync?.complete();</div><div>        _existingSync = null;</div><div>      }</div><div>    } catch (e, s) {</div><div>      _existingSync?.complete();</div><div>      _existingSync = null;</div><div>      _logger.warning(&quot;Error executing remote sync&quot;, e, s);</div><div></div><div>      if (flagService.internalUser ||</div><div>          // rethrow whitelisted error so that UI status can be updated correctly.</div><div>          {</div><div>            UnauthorizedError,</div><div>            NoActiveSubscriptionError,</div><div>            WiFiUnavailableError,</div><div>            StorageLimitExceededError,</div><div>            SyncStopRequestedError,</div><div>            NoMediaLocationAccessError,</div><div>          }.contains(e.runtimeType)) {</div><div>        rethrow;</div><div>      }</div><div>    } finally {</div><div>      _isExistingSyncSilent = false;</div><div>    }</div><div>  }</div><div></div><div>  bool isFirstRemoteSyncDone() {</div><div>    return _prefs.containsKey(_isFirstRemoteSyncDone);</div><div>  }</div><div></div><div>  Future&lt;bool&gt; whiteListVideoForUpload(EnteFile file) async {</div><div>    if (file.fileType == FileType.video &amp;&amp;</div><div>        !_config.shouldBackupVideos() &amp;&amp;</div><div>        file.localID != null) {</div><div>      final List&lt;String&gt; whitelistedIDs =</div><div>          _prefs.getStringList(_ignoreBackUpSettingsForIDs_) ?? &lt;String&gt;[];</div><div>      whitelistedIDs.add(file.localID!);</div><div>      return _prefs.setStringList(_ignoreBackUpSettingsForIDs_, whitelistedIDs);</div><div>    }</div><div>    return false;</div><div>  }</div><div></div><div>  Future&lt;void&gt; _pullDiff() async {</div><div>    _logger.info(&quot;Pulling remote diff&quot;);</div><div>    final isFirstSync = !_collectionsService.hasSyncedCollections();</div><div>    if (isFirstSync &amp;&amp; !_isExistingSyncSilent) {</div><div>      Bus.instance.fire(SyncStatusUpdate(SyncStatus.applyingRemoteDiff));</div><div>    }</div><div>    await _collectionsService.sync();</div><div>    // check and reset user&#039;s collection syncTime in past for older clients</div><div>    if (isFirstSync) {</div><div>      // not need reset syncTime, mark all flags as done if firstSync</div><div>      await _markResetSyncTimeAsDone();</div><div>    } else if (_shouldResetSyncTime()) {</div><div>      _logger.warning(&#039;Resetting syncTime for for the client&#039;);</div><div>      await _resetAllCollectionsSyncTime();</div><div>      await _markResetSyncTimeAsDone();</div><div>    }</div><div></div><div>    final idsToRemoteUpdationTimeMap =</div><div>        await _collectionsService.getCollectionIDsToBeSynced();</div><div>    await _syncUpdatedCollections(idsToRemoteUpdationTimeMap);</div><div>    unawaited(_localFileUpdateService.markUpdatedFilesForReUpload());</div><div>    unawaited(_notifyNewFiles(idsToRemoteUpdationTimeMap.keys.toList()));</div><div>  }</div><div></div><div>  Future&lt;void&gt; _syncUpdatedCollections(</div><div>    final Map&lt;int, int&gt; idsToRemoteUpdationTimeMap,</div><div>  ) async {</div><div>    for (final cid in idsToRemoteUpdationTimeMap.keys) {</div><div>      await _syncCollectionDiff(</div><div>        cid,</div><div>        _collectionsService.getCollectionSyncTime(cid),</div><div>      );</div><div>      // update syncTime for the collection in sharedPrefs. Note: the</div><div>      // syncTime can change on remote but we might not get a diff for the</div><div>      // collection if there are not changes in the file, but the collection</div><div>      // metadata (name, archive status, sharing etc) has changed.</div><div>      final remoteUpdateTime = idsToRemoteUpdationTimeMap[cid];</div><div>      await _collectionsService.setCollectionSyncTime(cid, remoteUpdateTime);</div><div>    }</div><div>    _logger.info(&quot;All updated collections synced&quot;);</div><div>    Bus.instance.fire(DiffSyncCompleteEvent());</div><div>  }</div><div></div><div>  Future&lt;void&gt; _resetAllCollectionsSyncTime() async {</div><div>    final resetSyncTime = _getSinceTimeForReSync();</div><div>    _logger.info(&#039;re-setting all collections syncTime to: $resetSyncTime&#039;);</div><div>    final collections = _collectionsService.getActiveCollections();</div><div>    for (final c in collections) {</div><div>      final int newSyncTime =</div><div>          min(_collectionsService.getCollectionSyncTime(c.id), resetSyncTime);</div><div>      await _collectionsService.setCollectionSyncTime(c.id, newSyncTime);</div><div>    }</div><div>  }</div><div></div><div>  Future&lt;void&gt; _syncCollectionDiff(int collectionID, int sinceTime) async {</div><div>    _logger.info(</div><div>      &quot;[Collection-$collectionID] fetch diff silently: $_isExistingSyncSilent &quot;</div><div>      &quot;since: $sinceTime&quot;,</div><div>    );</div><div>    if (!_isExistingSyncSilent) {</div><div>      Bus.instance.fire(SyncStatusUpdate(SyncStatus.applyingRemoteDiff));</div><div>    }</div><div>    final diff =</div><div>        await _diffFetcher.getEncryptedFilesDiff(collectionID, sinceTime);</div><div>    if (diff.deletedFiles.isNotEmpty) {</div><div>      await _syncCollectionDiffDelete(diff, collectionID);</div><div>    }</div><div>    if (diff.updatedFiles.isNotEmpty) {</div><div>      await _storeDiff(diff.updatedFiles, collectionID);</div><div>      _logger.info(</div><div>        &quot;[Collection-$collectionID] Updated ${diff.updatedFiles.length} files&quot;</div><div>        &quot; from remote&quot;,</div><div>      );</div><div>      Bus.instance.fire(</div><div>        LocalPhotosUpdatedEvent(</div><div>          diff.updatedFiles,</div><div>          source: &quot;syncUpdateFromRemote&quot;,</div><div>        ),</div><div>      );</div><div>      Bus.instance.fire(</div><div>        CollectionUpdatedEvent(</div><div>          collectionID,</div><div>          diff.updatedFiles,</div><div>          &quot;syncUpdateFromRemote&quot;,</div><div>        ),</div><div>      );</div><div>    }</div><div></div><div>    if (diff.latestUpdatedAtTime &gt; 0) {</div><div>      await _collectionsService.setCollectionSyncTime(</div><div>        collectionID,</div><div>        diff.latestUpdatedAtTime,</div><div>      );</div><div>    }</div><div>    if (diff.hasMore) {</div><div>      return await _syncCollectionDiff(</div><div>        collectionID,</div><div>        _collectionsService.getCollectionSyncTime(collectionID),</div><div>      );</div><div>    }</div><div>    _logger.info(&quot;[Collection-$collectionID] synced&quot;);</div><div>  }</div><div></div><div>  Future&lt;void&gt; joinAndSyncCollection(</div><div>    BuildContext context,</div><div>    int collectionID,</div><div>  ) async {</div><div>    await _collectionsService.joinPublicCollection(context, collectionID);</div><div>    await _collectionsService.sync();</div><div>    await _syncCollectionDiff(collectionID, 0);</div><div>  }</div><div></div><div>  Future&lt;void&gt; _syncCollectionDiffDelete(Diff diff, int collectionID) async {</div><div>    final fileIDs = diff.deletedFiles.map((f) =&gt; f.uploadedFileID!).toList();</div><div>    final localDeleteCount =</div><div>        await _db.deleteFilesFromCollection(collectionID, fileIDs);</div><div>    if (localDeleteCount &gt; 0) {</div><div>      final collectionFiles =</div><div>          (await _db.getFileIDToFileFromIDs(fileIDs)).values.toList();</div><div>      collectionFiles.removeWhere((f) =&gt; f.collectionID != collectionID);</div><div>      Bus.instance.fire(</div><div>        CollectionUpdatedEvent(</div><div>          collectionID,</div><div>          collectionFiles,</div><div>          &quot;syncDeleteFromRemote&quot;,</div><div>          type: EventType.deletedFromRemote,</div><div>        ),</div><div>      );</div><div>      Bus.instance.fire(</div><div>        LocalPhotosUpdatedEvent(</div><div>          collectionFiles,</div><div>          type: EventType.deletedFromRemote,</div><div>          source: &quot;syncDeleteFromRemote&quot;,</div><div>        ),</div><div>      );</div><div>    }</div><div>  }</div><div></div><div>  Future&lt;void&gt; syncDeviceCollectionFilesForUpload() async {</div><div>    _logger.info(&quot;Syncing device collections to be uploaded&quot;);</div><div>    final int ownerID = _config.getUserID()!;</div><div></div><div>    final deviceCollections = await _db.getDeviceCollections();</div><div>    deviceCollections.removeWhere((element) =&gt; !element.shouldBackup);</div><div>    // Sort by count to ensure that photos in iOS are first inserted in</div><div>    // smallest album marked for backup. This is to ensure that photo is</div><div>    // first attempted to upload in a non-recent album.</div><div>    deviceCollections.sort((a, b) =&gt; a.count.compareTo(b.count));</div><div>    final Map&lt;String, Set&lt;String&gt;&gt; pathIdToLocalIDs =</div><div>        await _db.getDevicePathIDToLocalIDMap();</div><div>    bool moreFilesMarkedForBackup = false;</div><div>    for (final deviceCollection in deviceCollections) {</div><div>      final Set&lt;String&gt; localIDsToSync =</div><div>          pathIdToLocalIDs[deviceCollection.id] ?? {};</div><div>      if (deviceCollection.uploadStrategy == UploadStrategy.ifMissing) {</div><div>        final Set&lt;String&gt; alreadyClaimedLocalIDs =</div><div>            await _db.getLocalIDsMarkedForOrAlreadyUploaded(ownerID);</div><div>        localIDsToSync.removeAll(alreadyClaimedLocalIDs);</div><div>        if (alreadyClaimedLocalIDs.isNotEmpty &amp;&amp; !_hasCleanupStaleEntry) {</div><div>          try {</div><div>            await _db.removeQueuedLocalFiles(alreadyClaimedLocalIDs, ownerID);</div><div>          } catch (e, s) {</div><div>            _logger.severe(&quot;removeQueuedLocalFiles failed&quot;, e, s);</div><div>          }</div><div>        }</div><div>      }</div><div></div><div>      if (localIDsToSync.isEmpty) {</div><div>        continue;</div><div>      }</div><div>      final collectionID = await _getCollectionID(deviceCollection);</div><div>      if (collectionID == null) {</div><div>        _logger.warning(&#039;DeviceCollection was either deleted or missing&#039;);</div><div>        continue;</div><div>      }</div><div></div><div>      moreFilesMarkedForBackup = true;</div><div>      await _db.setCollectionIDForUnMappedLocalFiles(</div><div>        collectionID,</div><div>        localIDsToSync,</div><div>      );</div><div></div><div>      // mark IDs as already synced if corresponding entry is present in</div><div>      // the collection. This can happen when a user has marked a folder</div><div>      // for sync, then un-synced it and again tries to mark if for sync.</div><div>      final Set&lt;String&gt; existingMapping =</div><div>          await _db.getLocalFileIDsForCollection(collectionID);</div><div>      final Set&lt;String&gt; commonElements =</div><div>          localIDsToSync.intersection(existingMapping);</div><div>      if (commonElements.isNotEmpty) {</div><div>        debugPrint(</div><div>          &quot;${commonElements.length} files already existing in &quot;</div><div>          &quot;collection $collectionID for ${deviceCollection.name}&quot;,</div><div>        );</div><div>        localIDsToSync.removeAll(commonElements);</div><div>      }</div><div></div><div>      // At this point, the remaining localIDsToSync will need to create</div><div>      // new file entries, where we can store mapping for localID and</div><div>      // corresponding collection ID</div><div>      if (localIDsToSync.isNotEmpty) {</div><div>        debugPrint(</div><div>          &#039;Adding new entries for ${localIDsToSync.length} files&#039;</div><div>          &#039; for ${deviceCollection.name}&#039;,</div><div>        );</div><div>        final filesWithCollectionID =</div><div>            await _db.getLocalFiles(localIDsToSync.toList());</div><div>        final List&lt;EnteFile&gt; newFilesToInsert = [];</div><div>        final Set&lt;String&gt; fileFoundForLocalIDs = {};</div><div>        for (var existingFile in filesWithCollectionID) {</div><div>          final String localID = existingFile.localID!;</div><div>          if (!fileFoundForLocalIDs.contains(localID)) {</div><div>            existingFile.generatedID = null;</div><div>            existingFile.collectionID = collectionID;</div><div>            existingFile.uploadedFileID = null;</div><div>            existingFile.ownerID = null;</div><div>            newFilesToInsert.add(existingFile);</div><div>            fileFoundForLocalIDs.add(localID);</div><div>          }</div><div>        }</div><div>        await _db.insertMultiple(newFilesToInsert);</div><div>        if (fileFoundForLocalIDs.length != localIDsToSync.length) {</div><div>          _logger.warning(</div><div>            &quot;mismatch in num of filesToSync ${localIDsToSync.length} to &quot;</div><div>            &quot;fileSynced ${fileFoundForLocalIDs.length}&quot;,</div><div>          );</div><div>        }</div><div>      }</div><div>    }</div><div>    if (moreFilesMarkedForBackup &amp;&amp; !_config.hasSelectedAllFoldersForBackup()) {</div><div>      // &quot;force reload due to display new files&quot;</div><div>      Bus.instance.fire(ForceReloadHomeGalleryEvent(&quot;newFilesDisplay&quot;));</div><div>    }</div><div>    _hasCleanupStaleEntry = true;</div><div>  }</div><div></div><div>  Future&lt;void&gt; updateDeviceFolderSyncStatus(</div><div>    Map&lt;String, bool&gt; syncStatusUpdate,</div><div>  ) async {</div><div>    final Set&lt;int&gt; oldCollectionIDsForAutoSync =</div><div>        await _db.getDeviceSyncCollectionIDs();</div><div>    await _db.updateDevicePathSyncStatus(syncStatusUpdate);</div><div>    final Set&lt;int&gt; newCollectionIDsForAutoSync =</div><div>        await _db.getDeviceSyncCollectionIDs();</div><div>    SyncService.instance.onDeviceCollectionSet(newCollectionIDsForAutoSync);</div><div>    // remove all collectionIDs which are still marked for backup</div><div>    oldCollectionIDsForAutoSync.removeAll(newCollectionIDsForAutoSync);</div><div>    await removeFilesQueuedForUpload(oldCollectionIDsForAutoSync.toList());</div><div>    if (syncStatusUpdate.values.any((syncStatus) =&gt; syncStatus == false)) {</div><div>      Configuration.instance.setSelectAllFoldersForBackup(false).ignore();</div><div>    }</div><div>    Bus.instance.fire(</div><div>      LocalPhotosUpdatedEvent(&lt;EnteFile&gt;[], source: &quot;deviceFolderSync&quot;),</div><div>    );</div><div>    Bus.instance.fire(BackupFoldersUpdatedEvent());</div><div>  }</div><div></div><div>  Future&lt;void&gt; removeFilesQueuedForUpload(List&lt;int&gt; collectionIDs) async {</div><div>    /*</div><div>      For each collection, perform following action</div><div>      1) Get List of all files not uploaded yet</div><div>      2) Delete files who localIDs is also present in other collections.</div><div>      3) For Remaining files, set the collectionID as -1</div><div>     */</div><div>    _logger.info(&quot;Removing files for collections $collectionIDs&quot;);</div><div>    for (int collectionID in collectionIDs) {</div><div>      final List&lt;EnteFile&gt; pendingUploads =</div><div>          await _db.getPendingUploadForCollection(collectionID);</div><div>      if (pendingUploads.isEmpty) {</div><div>        continue;</div><div>      } else {</div><div>        _logger.info(</div><div>          &quot;RemovingFiles $collectionIDs: pendingUploads &quot;</div><div>          &quot;${pendingUploads.length}&quot;,</div><div>        );</div><div>      }</div><div>      final Set&lt;String&gt; localIDsInOtherFileEntries =</div><div>          await _db.getLocalIDsPresentInEntries(</div><div>        pendingUploads,</div><div>        collectionID,</div><div>      );</div><div>      _logger.info(</div><div>        &quot;RemovingFiles $collectionIDs: filesInOtherCollection &quot;</div><div>        &quot;${localIDsInOtherFileEntries.length}&quot;,</div><div>      );</div><div>      final List&lt;EnteFile&gt; entriesToUpdate = [];</div><div>      final List&lt;int&gt; entriesToDelete = [];</div><div>      for (EnteFile pendingUpload in pendingUploads) {</div><div>        if (localIDsInOtherFileEntries.contains(pendingUpload.localID)) {</div><div>          entriesToDelete.add(pendingUpload.generatedID!);</div><div>        } else {</div><div>          pendingUpload.collectionID = null;</div><div>          entriesToUpdate.add(pendingUpload);</div><div>        }</div><div>      }</div><div>      await _db.deleteMultipleByGeneratedIDs(entriesToDelete);</div><div>      await _db.insertMultiple(entriesToUpdate);</div><div>      _logger.info(</div><div>        &quot;RemovingFiles $collectionIDs: deleted &quot;</div><div>        &quot;${entriesToDelete.length} and updated ${entriesToUpdate.length}&quot;,</div><div>      );</div><div>    }</div><div>  }</div><div></div><div>  Future&lt;int?&gt; _getCollectionID(DeviceCollection deviceCollection) async {</div><div>    if (deviceCollection.hasCollectionID()) {</div><div>      final collection =</div><div>          _collectionsService.getCollectionByID(deviceCollection.collectionID!);</div><div>      if (collection != null &amp;&amp; !collection.isDeleted) {</div><div>        return collection.id;</div><div>      }</div><div>      if (collection == null) {</div><div>        // ideally, this should never happen because the app keeps a track of</div><div>        // all collections and their IDs. But, if somehow the collection is</div><div>        // deleted, we should fetch it again</div><div>        _logger.severe(</div><div>          &quot;Collection ${deviceCollection.collectionID} missing &quot;</div><div>          &quot;for pathID ${deviceCollection.id}&quot;,</div><div>        );</div><div>        _collectionsService</div><div>            .fetchCollectionByID(deviceCollection.collectionID!)</div><div>            .ignore();</div><div>        // return, by next run collection should be available.</div><div>        // we are not waiting on fetch by choice because device might have wrong</div><div>        // mapping which will result in breaking upload for other device path</div><div>        return null;</div><div>      } else if (collection.isDeleted) {</div><div>        _logger.warning(&quot;Collection ${deviceCollection.collectionID} deleted &quot;</div><div>            &quot;for pathID ${deviceCollection.id}, new collection will be created&quot;);</div><div>      }</div><div>    }</div><div>    final collection =</div><div>        await _collectionsService.getOrCreateForPath(deviceCollection.name);</div><div>    await _db.updateDeviceCollection(deviceCollection.id, collection.id);</div><div>    return collection.id;</div><div>  }</div><div></div><div>  Future&lt;List&lt;EnteFile&gt;&gt; _getFilesToBeUploaded() async {</div><div>    final List&lt;EnteFile&gt; originalFiles = await _db.getFilesPendingForUpload();</div><div>    if (originalFiles.isEmpty) {</div><div>      return originalFiles;</div><div>    }</div><div>    final bool shouldRemoveVideos =</div><div>        !_config.shouldBackupVideos() || bgWithoutResumableUpload;</div><div>    final ignoredIDs = await IgnoredFilesService.instance.idToIgnoreReasonMap;</div><div>    bool shouldSkipUploadFunc(EnteFile file) {</div><div>      return IgnoredFilesService.instance.shouldSkipUpload(ignoredIDs, file);</div><div>    }</div><div></div><div>    final List&lt;EnteFile&gt; filesToBeUploaded = [];</div><div>    int ignoredForUpload = 0;</div><div>    int skippedVideos = 0;</div><div>    final whitelistedIDs =</div><div>        (_prefs.getStringList(_ignoreBackUpSettingsForIDs_) ?? &lt;String&gt;[])</div><div>            .toSet();</div><div>    for (var file in originalFiles) {</div><div>      if (shouldRemoveVideos &amp;&amp;</div><div>          (file.fileType == FileType.video &amp;&amp;</div><div>              !whitelistedIDs.contains(file.localID))) {</div><div>        skippedVideos++;</div><div>        continue;</div><div>      }</div><div>      if (shouldSkipUploadFunc(file)) {</div><div>        ignoredForUpload++;</div><div>        continue;</div><div>      }</div><div>      filesToBeUploaded.add(file);</div><div>    }</div><div>    if (skippedVideos &gt; 0 || ignoredForUpload &gt; 0) {</div><div>      _logger.info(&quot;Skipped $skippedVideos videos and $ignoredForUpload &quot;</div><div>          &quot;ignored files for upload&quot;);</div><div>    }</div><div>    _sortByTime(filesToBeUploaded);</div><div>    _logger.info(&quot;${filesToBeUploaded.length} new files to be uploaded.&quot;);</div><div>    return filesToBeUploaded;</div><div>  }</div><div></div><div>  Future&lt;bool&gt; _uploadFiles(List&lt;EnteFile&gt; filesToBeUploaded) async {</div><div>    final int ownerID = _config.getUserID()!;</div><div>    final updatedFileIDs = await _db.getUploadedFileIDsToBeUpdated(ownerID);</div><div>    if (updatedFileIDs.isNotEmpty) {</div><div>      _logger.info(&quot;Identified ${updatedFileIDs.length} files for reupload&quot;);</div><div>    }</div><div></div><div>    _completedUploads = 0;</div><div>    _ignoredUploads = 0;</div><div>    final int toBeUploaded = filesToBeUploaded.length + updatedFileIDs.length;</div><div></div><div>    if (toBeUploaded &gt; 0) {</div><div>      _logger.internalInfo(</div><div>        &quot;[UPLOAD-DEBUG] Preparing to upload $toBeUploaded files &quot;</div><div>        &quot;(${filesToBeUploaded.length} new, ${updatedFileIDs.length} updated) &quot;</div><div>        &quot;in ${isProcessBg ? &#039;BACKGROUND&#039; : &#039;FOREGROUND&#039;} mode&quot;,</div><div>      );</div><div></div><div>      Bus.instance.fire(</div><div>        SyncStatusUpdate(SyncStatus.preparingForUpload, total: toBeUploaded),</div><div>      );</div><div>      _logger.internalInfo(</div><div>        &quot;[UPLOAD-DEBUG] Fired preparingForUpload status update&quot;,</div><div>      );</div><div></div><div>      // Step 1: Verify media location access permission</div><div>      _logger.internalInfo(</div><div>        &quot;[UPLOAD-DEBUG] Step 1/3: Checking media location access permission...&quot;,</div><div>      );</div><div>      await _uploader.verifyMediaLocationAccess();</div><div>      _logger.internalInfo(</div><div>        &quot;[UPLOAD-DEBUG] Step 1/3: Media location access verified ✓&quot;,</div><div>      );</div><div></div><div>      // Step 2: Check network availability for upload</div><div>      _logger.internalInfo(</div><div>        &quot;[UPLOAD-DEBUG] Step 2/3: Checking network availability for upload...&quot;,</div><div>      );</div><div>      await _uploader.checkNetworkForUpload();</div><div>      _logger.internalInfo(&quot;[UPLOAD-DEBUG] Step 2/3: Network check passed ✓&quot;);</div><div></div><div>      // Step 3: Fetch upload URLs from server</div><div>      _logger.internalInfo(</div><div>        &quot;[UPLOAD-DEBUG] Step 3/3: Fetching upload URLs from server for $toBeUploaded files...&quot;,</div><div>      );</div><div>      await _uploader.fetchUploadURLs(toBeUploaded);</div><div>      _logger.internalInfo(</div><div>        &quot;[UPLOAD-DEBUG] Step 3/3: Upload URLs fetched successfully ✓&quot;,</div><div>      );</div><div></div><div>      _logger.internalInfo(</div><div>        &quot;[UPLOAD-DEBUG] All pre-upload checks completed successfully! &quot;</div><div>        &quot;Proceeding to queue individual file uploads...&quot;,</div><div>      );</div><div>    } else {</div><div>      _logger.internalInfo(</div><div>        &quot;[UPLOAD-DEBUG] No files to upload, skipping upload preparation&quot;,</div><div>      );</div><div>    }</div><div>    final List&lt;Future&gt; futures = [];</div><div></div><div>    _logger.internalInfo(</div><div>      &quot;[UPLOAD-DEBUG] Starting to queue ${filesToBeUploaded.length} new files for upload...&quot;,</div><div>    );</div><div>    int queuedCount = 0;</div><div>    for (final file in filesToBeUploaded) {</div><div>      if (shouldThrottleUpload &amp;&amp;</div><div>          futures.length &gt;= kMaximumPermissibleUploadsInThrottledMode) {</div><div>        _logger.internalInfo(</div><div>          &quot;[UPLOAD-DEBUG] Throttle limit reached (${futures.length} files queued). &quot;</div><div>          &quot;Skipping remaining ${filesToBeUploaded.length - queuedCount} files.&quot;,</div><div>        );</div><div>        break;</div><div>      }</div><div>      // prefer existing collection ID for manually uploaded files.</div><div>      // See https://github.com/ente-io/photos-app/pull/187</div><div>      _logger.internalInfo(</div><div>        &quot;[UPLOAD-DEBUG] Queueing file ${queuedCount + 1}/${filesToBeUploaded.length}: &quot;</div><div>        &quot;${file.title} (localID: ${file.localID}, generatedID: ${file.generatedID})&quot;,</div><div>      );</div><div>      try {</div><div>        final collectionID = file.collectionID ??</div><div>            (await _collectionsService.getOrCreateForPath(</div><div>              file.deviceFolder ?? &#039;Unknown Folder&#039;,</div><div>            ))</div><div>                .id;</div><div>        _logger.internalInfo(</div><div>          &quot;[UPLOAD-DEBUG] Resolved collectionID: $collectionID for file ${file.title}&quot;,</div><div>        );</div><div>        _uploadFile(file, collectionID, futures);</div><div>        queuedCount++;</div><div>        _logger.internalInfo(</div><div>          &quot;[UPLOAD-DEBUG] Successfully queued file ${file.title} ($queuedCount queued so far)&quot;,</div><div>        );</div><div>      } catch (e, s) {</div><div>        _logger.internalSevere(</div><div>          &quot;[UPLOAD-DEBUG] Failed to queue file ${file.title}&quot;,</div><div>          e,</div><div>          s,</div><div>        );</div><div>      }</div><div>    }</div><div>    _logger.internalInfo(</div><div>      &quot;[UPLOAD-DEBUG] Finished queueing new files. Total queued: $queuedCount/${filesToBeUploaded.length}&quot;,</div><div>    );</div><div></div><div>    _logger.internalInfo(</div><div>      &quot;[UPLOAD-DEBUG] Starting to queue ${updatedFileIDs.length} updated files for re-upload...&quot;,</div><div>    );</div><div>    int reuploadQueuedCount = 0;</div><div>    for (final uploadedFileID in updatedFileIDs) {</div><div>      if (shouldThrottleUpload &amp;&amp;</div><div>          futures.length &gt;= kMaximumPermissibleUploadsInThrottledMode) {</div><div>        _logger.internalInfo(</div><div>          &quot;[UPLOAD-DEBUG] Throttle limit reached for re-uploads (${futures.length} total queued). &quot;</div><div>          &quot;Skipping remaining ${updatedFileIDs.length - reuploadQueuedCount} updated files.&quot;,</div><div>        );</div><div>        break;</div><div>      }</div><div>      _logger.internalInfo(</div><div>        &quot;[UPLOAD-DEBUG] Processing updated file ${reuploadQueuedCount + 1}/${updatedFileIDs.length} &quot;</div><div>        &quot;(uploadedFileID: $uploadedFileID)&quot;,</div><div>      );</div><div>      try {</div><div>        final allFiles = await _db.getFilesInAllCollection(</div><div>          uploadedFileID,</div><div>          ownerID,</div><div>        );</div><div>        if (allFiles.isEmpty) {</div><div>          _logger.internalWarning(</div><div>            &quot;[UPLOAD-DEBUG] No files found for uploadedFileID $uploadedFileID, skipping&quot;,</div><div>          );</div><div>          continue;</div><div>        }</div><div>        _logger.internalInfo(</div><div>          &quot;[UPLOAD-DEBUG] Found ${allFiles.length} file(s) for uploadedFileID $uploadedFileID&quot;,</div><div>        );</div><div>        EnteFile? fileInCollectionOwnedByUser;</div><div>        for (final file in allFiles) {</div><div>          if (file.canReUpload(ownerID)) {</div><div>            fileInCollectionOwnedByUser = file;</div><div>            break;</div><div>          }</div><div>        }</div><div>        if (fileInCollectionOwnedByUser != null) {</div><div>          _logger.internalInfo(</div><div>            &quot;[UPLOAD-DEBUG] Queueing re-upload for ${fileInCollectionOwnedByUser.title}&quot;,</div><div>          );</div><div>          _uploadFile(</div><div>            fileInCollectionOwnedByUser,</div><div>            fileInCollectionOwnedByUser.collectionID!,</div><div>            futures,</div><div>          );</div><div>          reuploadQueuedCount++;</div><div>          _logger.internalInfo(</div><div>            &quot;[UPLOAD-DEBUG] Successfully queued re-upload ($reuploadQueuedCount re-uploads queued)&quot;,</div><div>          );</div><div>        } else {</div><div>          _logger.internalWarning(</div><div>            &quot;[UPLOAD-DEBUG] No re-uploadable file found for uploadedFileID $uploadedFileID&quot;,</div><div>          );</div><div>        }</div><div>      } catch (e, s) {</div><div>        _logger.internalSevere(</div><div>          &quot;[UPLOAD-DEBUG] Failed to queue re-upload for uploadedFileID $uploadedFileID&quot;,</div><div>          e,</div><div>          s,</div><div>        );</div><div>      }</div><div>    }</div><div>    _logger.internalInfo(</div><div>      &quot;[UPLOAD-DEBUG] Finished queueing updated files. Total re-uploads queued: &quot;</div><div>      &quot;$reuploadQueuedCount/${updatedFileIDs.length}&quot;,</div><div>    );</div><div></div><div>    _logger.internalInfo(</div><div>      &quot;[UPLOAD-DEBUG] ═══════════════════════════════════════════════════════&quot;,</div><div>    );</div><div>    _logger.internalInfo(</div><div>      &quot;[UPLOAD-DEBUG] SUMMARY: Total ${futures.length} upload futures queued&quot;,</div><div>    );</div><div>    _logger.internalInfo(</div><div>      &quot;[UPLOAD-DEBUG] - New files queued: $queuedCount/${filesToBeUploaded.length}&quot;,</div><div>    );</div><div>    _logger.internalInfo(</div><div>      &quot;[UPLOAD-DEBUG] - Re-uploads queued: $reuploadQueuedCount/${updatedFileIDs.length}&quot;,</div><div>    );</div><div>    _logger.internalInfo(</div><div>      &quot;[UPLOAD-DEBUG] - Process mode: ${isProcessBg ? &#039;BACKGROUND&#039; : &#039;FOREGROUND&#039;}&quot;,</div><div>    );</div><div>    _logger.internalInfo(</div><div>      &quot;[UPLOAD-DEBUG] Now waiting for all ${futures.length} upload futures to complete...&quot;,</div><div>    );</div><div>    _logger.internalInfo(</div><div>      &quot;[UPLOAD-DEBUG] ═══════════════════════════════════════════════════════&quot;,</div><div>    );</div><div></div><div>    try {</div><div>      await Future.wait(futures);</div><div>      _logger.internalInfo(</div><div>        &quot;[UPLOAD-DEBUG] All upload futures completed successfully! &quot;</div><div>        &quot;Completed: $_completedUploads, Ignored: $_ignoredUploads&quot;,</div><div>      );</div><div>    } on InvalidFileError catch (e, s) {</div><div>      _logger.internalWarning(</div><div>        &quot;[UPLOAD-DEBUG] InvalidFileError caught (ignored)&quot;,</div><div>        e,</div><div>        s,</div><div>      );</div><div>      // Do nothing</div><div>    } on FileSystemException catch (e, s) {</div><div>      _logger.internalWarning(</div><div>        &quot;[UPLOAD-DEBUG] FileSystemException caught (ignored - likely concurrency issue)&quot;,</div><div>        e,</div><div>        s,</div><div>      );</div><div>      // Do nothing since it&#039;s caused mostly due to concurrency issues</div><div>      // when the foreground app deletes temporary files, interrupting a background</div><div>      // upload</div><div>    } on LockAlreadyAcquiredError catch (e, s) {</div><div>      _logger.internalWarning(</div><div>        &quot;[UPLOAD-DEBUG] LockAlreadyAcquiredError caught (ignored)&quot;,</div><div>        e,</div><div>        s,</div><div>      );</div><div>      // Do nothing</div><div>    } on SilentlyCancelUploadsError catch (e, s) {</div><div>      _logger.internalWarning(</div><div>        &quot;[UPLOAD-DEBUG] SilentlyCancelUploadsError caught (ignored)&quot;,</div><div>        e,</div><div>        s,</div><div>      );</div><div>      // Do nothing</div><div>    } on UserCancelledUploadError catch (e, s) {</div><div>      _logger.internalWarning(</div><div>        &quot;[UPLOAD-DEBUG] UserCancelledUploadError caught (ignored)&quot;,</div><div>        e,</div><div>        s,</div><div>      );</div><div>      // Do nothing</div><div>    } catch (e, s) {</div><div>      _logger.internalSevere(</div><div>        &quot;[UPLOAD-DEBUG] Unexpected error during upload&quot;,</div><div>        e,</div><div>        s,</div><div>      );</div><div>      rethrow;</div><div>    }</div><div></div><div>    final hasUploaded = _completedUploads &gt; 0;</div><div>    _logger.internalInfo(</div><div>      &quot;[UPLOAD-DEBUG] Upload process finished. Returning hasUploaded=$hasUploaded &quot;</div><div>      &quot;(completedUploads: $_completedUploads)&quot;,</div><div>    );</div><div>    return hasUploaded;</div><div>  }</div><div></div><div>  void _uploadFile(EnteFile file, int collectionID, List&lt;Future&gt; futures) {</div><div>    _logger.internalInfo(</div><div>      &quot;[UPLOAD-DEBUG] _uploadFile() called for ${file.title} &quot;</div><div>      &quot;(localID: ${file.localID}, collectionID: $collectionID). &quot;</div><div>      &quot;Calling FileUploader.upload()...&quot;,</div><div>    );</div><div>    final future = _uploader.upload(file, collectionID).then((uploadedFile) {</div><div>      _logger.internalInfo(</div><div>        &quot;[UPLOAD-DEBUG] Upload completed successfully for ${uploadedFile.title}&quot;,</div><div>      );</div><div>      return _onFileUploaded(uploadedFile);</div><div>    }).onError((error, stackTrace) {</div><div>      _logger.internalSevere(</div><div>        &quot;[UPLOAD-DEBUG] Upload failed for ${file.title}&quot;,</div><div>        error,</div><div>        stackTrace,</div><div>      );</div><div>      return _onFileUploadError(error, stackTrace, file);</div><div>    });</div><div>    futures.add(future);</div><div>    _logger.internalInfo(</div><div>      &quot;[UPLOAD-DEBUG] Upload future added to futures list for ${file.title} &quot;</div><div>      &quot;(futures count: ${futures.length})&quot;,</div><div>    );</div><div>  }</div><div></div><div>  Future&lt;void&gt; _onFileUploaded(EnteFile file) async {</div><div>    Bus.instance.fire(</div><div>      CollectionUpdatedEvent(file.collectionID, [file], &quot;fileUpload&quot;),</div><div>    );</div><div>    _completedUploads++;</div><div>    final toBeUploadedInThisSession = _uploader.getCurrentSessionUploadCount();</div><div>    if (toBeUploadedInThisSession == 0) {</div><div>      return;</div><div>    }</div><div>    if (_completedUploads &gt; toBeUploadedInThisSession ||</div><div>        _completedUploads &lt; 0 ||</div><div>        toBeUploadedInThisSession &lt; 0) {</div><div>      _logger.info(</div><div>        &quot;Incorrect sync status&quot;,</div><div>        InvalidSyncStatusError(</div><div>          &quot;Tried to report $_completedUploads as &quot;</div><div>          &quot;uploaded out of $toBeUploadedInThisSession&quot;,</div><div>        ),</div><div>      );</div><div>      return;</div><div>    }</div><div>    Bus.instance.fire(</div><div>      SyncStatusUpdate(</div><div>        SyncStatus.inProgress,</div><div>        completed: _completedUploads,</div><div>        total: toBeUploadedInThisSession,</div><div>      ),</div><div>    );</div><div>  }</div><div></div><div>  void _onFileUploadError(</div><div>    Object? error,</div><div>    StackTrace stackTrace,</div><div>    EnteFile file,</div><div>  ) {</div><div>    if (error == null) {</div><div>      return;</div><div>    }</div><div>    if (error is InvalidFileError) {</div><div>      _ignoredUploads++;</div><div>      _logger.warning(&quot;Invalid file error&quot;, error);</div><div>    } else {</div><div>      throw error;</div><div>    }</div><div>  }</div><div></div><div>  /* _storeDiff maps each remoteFile to existing</div><div>      entries in files table. When match is found, it compares both file to</div><div>      perform relevant actions like</div><div>      [1] Clear local cache when required (Both Shared and Owned files)</div><div>      [2] Retain localID of remote file based on matching logic [Owned files]</div><div>      [3] Refresh UI if visibility or creationTime has changed [Owned files]</div><div>      [4] Schedule file update if the local file has changed since last time</div><div>      [Owned files]</div><div>    [Important Note: If given uploadedFileID and collectionID is already present</div><div>     in files db, the generateID should already point to existing entry.</div><div>     Known Issues:</div><div>      [K1] Cached entry will not be cleared when if a file was edited and</div><div>      moved to different collection as Vid/Image cache key is uploadedID.</div><div>      [Existing]</div><div>    ]</div><div>   */</div><div>  Future&lt;void&gt; _storeDiff(List&lt;EnteFile&gt; diff, int collectionID) async {</div><div>    int sharedFileNew = 0,</div><div>        sharedFileUpdated = 0,</div><div>        localUploadedFromDevice = 0,</div><div>        localButUpdatedOnDevice = 0,</div><div>        remoteNewFile = 0;</div><div>    final int userID = _config.getUserID()!;</div><div>    bool needsGalleryReload = false;</div><div>    // this is required when same file is uploaded twice in the same</div><div>    // collection. Without this check, if both remote files are part of same</div><div>    // diff response, then we end up inserting one entry instead of two</div><div>    // as we update the generatedID for remoteFile to local file&#039;s genID</div><div>    final Set&lt;int&gt; alreadyClaimedLocalFilesGenID = {};</div><div></div><div>    final List&lt;EnteFile&gt; toBeInserted = [];</div><div>    for (EnteFile remoteFile in diff) {</div><div>      // existingFile will be either set to existing collectionID+localID or</div><div>      // to the unclaimed aka not already linked to any uploaded file.</div><div>      EnteFile? existingFile;</div><div>      if (remoteFile.generatedID != null) {</div><div>        // Case [1] Check and clear local cache when uploadedFile already exist</div><div>        // Note: Existing file can be null here if it&#039;s replaced by the time we</div><div>        // reach here</div><div>        existingFile = await _db.getUploadedFile(</div><div>          remoteFile.uploadedFileID!,</div><div>          remoteFile.collectionID!,</div><div>        );</div><div>        if (existingFile != null &amp;&amp;</div><div>            _shouldClearCache(remoteFile, existingFile)) {</div><div>          needsGalleryReload = true;</div><div>          await clearCache(remoteFile);</div><div>        }</div><div>      }</div><div></div><div>      /* If file is not owned by the user, no further processing is required</div><div>      as Case [2,3,4] are only relevant to files owned by user</div><div>       */</div><div>      if (userID != remoteFile.ownerID) {</div><div>        if (existingFile == null) {</div><div>          sharedFileNew++;</div><div>          remoteFile.localID = null;</div><div>        } else {</div><div>          sharedFileUpdated++;</div><div>          // if user has downloaded the file on the device, avoid removing the</div><div>          // localID reference.</div><div>          // [Todo-fix: Excluded shared file&#039;s localIDs during syncALL]</div><div>          remoteFile.localID = existingFile.localID;</div><div>        }</div><div>        toBeInserted.add(remoteFile);</div><div>        // end processing for file here, move to next file now</div><div>        continue;</div><div>      }</div><div></div><div>      // If remoteFile was synced before, assign the localID of the existing</div><div>      // file entry.</div><div>      // If remoteFile is not synced before and has localID (i.e. existingFile</div><div>      // is null), check if the remoteFile was uploaded from this device.</div><div>      // Note: DeviceFolder is ignored for iOS during matching</div><div>      if (existingFile != null) {</div><div>        remoteFile.localID = existingFile.localID;</div><div>      } else if (remoteFile.localID != null &amp;&amp; existingFile == null) {</div><div>        final localFileEntries = await _db.getUnlinkedLocalMatchesForRemoteFile(</div><div>          userID,</div><div>          remoteFile.localID!,</div><div>          remoteFile.fileType,</div><div>          title: remoteFile.title ?? &#039;&#039;,</div><div>          deviceFolder: remoteFile.deviceFolder ?? &#039;&#039;,</div><div>        );</div><div>        if (localFileEntries.isEmpty) {</div><div>          // set remote file&#039;s localID as null because corresponding local file</div><div>          // does not exist [Case 2, do not retain localID of the remote file]</div><div>          remoteFile.localID = null;</div><div>        } else {</div><div>          // case 4: Check and schedule the file for update</div><div>          final int maxModificationTime = localFileEntries</div><div>              .map(</div><div>                (e) =&gt; e.modificationTime ?? 0,</div><div>              )</div><div>              .reduce(max);</div><div></div><div>          /* Note: In case of iOS, we will miss any asset modification in</div><div>            between of two installation. This is done to avoid fetching assets</div><div>            from iCloud when modification time could have changed for number of</div><div>            reasons. To fix this, we need to identify a way to store version</div><div>            for the adjustments or just if the asset has been modified ever.</div><div>            https://stackoverflow.com/a/50093266/546896</div><div>            */</div><div>          if (maxModificationTime &gt; remoteFile.modificationTime! &amp;&amp;</div><div>              Platform.isAndroid) {</div><div>            localButUpdatedOnDevice++;</div><div>            await FileUpdationDB.instance.insertMultiple(</div><div>              [remoteFile.localID!],</div><div>              FileUpdationDB.modificationTimeUpdated,</div><div>            );</div><div>          }</div><div></div><div>          localFileEntries.removeWhere(</div><div>            (e) =&gt;</div><div>                e.uploadedFileID != null ||</div><div>                alreadyClaimedLocalFilesGenID.contains(e.generatedID),</div><div>          );</div><div></div><div>          if (localFileEntries.isNotEmpty) {</div><div>            // file uploaded from same device, replace the local file row by</div><div>            // setting the generated ID of remoteFile to localFile generatedID</div><div>            existingFile = localFileEntries.first;</div><div>            localUploadedFromDevice++;</div><div>            alreadyClaimedLocalFilesGenID.add(existingFile.generatedID!);</div><div>            remoteFile.generatedID = existingFile.generatedID;</div><div>          }</div><div>        }</div><div>      }</div><div>      if (existingFile != null &amp;&amp;</div><div>          _shouldReloadHomeGallery(remoteFile, existingFile)) {</div><div>        needsGalleryReload = true;</div><div>      } else {</div><div>        remoteNewFile++;</div><div>      }</div><div>      toBeInserted.add(remoteFile);</div><div>    }</div><div>    await _db.insertMultiple(toBeInserted);</div><div>    _logger.info(</div><div>      &quot;Diff to be deduplicated was: &quot; +</div><div>          diff.length.toString() +</div><div>          &quot; out of which \n&quot; +</div><div>          localUploadedFromDevice.toString() +</div><div>          &quot; was uploaded from device, \n&quot; +</div><div>          localButUpdatedOnDevice.toString() +</div><div>          &quot; was uploaded from device, but has been updated since and should be reuploaded, \n&quot; +</div><div>          sharedFileNew.toString() +</div><div>          &quot; new sharedFiles, \n&quot; +</div><div>          sharedFileUpdated.toString() +</div><div>          &quot; updatedSharedFiles, and \n&quot; +</div><div>          remoteNewFile.toString() +</div><div>          &quot; remoteFiles seen first time&quot;,</div><div>    );</div><div>    if (needsGalleryReload) {</div><div>      // &#039;force reload home gallery&#039;</div><div>      Bus.instance.fire(ForceReloadHomeGalleryEvent(&quot;remoteSync&quot;));</div><div>    }</div><div>  }</div><div></div><div>  bool _shouldClearCache(EnteFile remoteFile, EnteFile existingFile) {</div><div>    if (remoteFile.hash != null &amp;&amp; existingFile.hash != null) {</div><div>      return remoteFile.hash != existingFile.hash;</div><div>    }</div><div>    return remoteFile.updationTime != (existingFile.updationTime ?? 0);</div><div>  }</div><div></div><div>  bool _shouldReloadHomeGallery(EnteFile remoteFile, EnteFile existingFile) {</div><div>    int remoteCreationTime = remoteFile.creationTime!;</div><div>    if (remoteFile.pubMmdVersion &gt; 0 &amp;&amp;</div><div>        (remoteFile.pubMagicMetadata?.editedTime ?? 0) != 0) {</div><div>      remoteCreationTime = remoteFile.pubMagicMetadata!.editedTime!;</div><div>    }</div><div>    if (remoteCreationTime != existingFile.creationTime) {</div><div>      return true;</div><div>    }</div><div>    if (existingFile.mMdVersion &gt; 0 &amp;&amp;</div><div>        remoteFile.mMdVersion != existingFile.mMdVersion &amp;&amp;</div><div>        remoteFile.magicMetadata.visibility !=</div><div>            existingFile.magicMetadata.visibility) {</div><div>      return false;</div><div>    }</div><div>    return false;</div><div>  }</div><div></div><div>  // return true if the client needs to re-sync the collections from previous</div><div>  // version</div><div>  bool _shouldResetSyncTime() {</div><div>    return !_prefs.containsKey(kHasSyncedEditTime) ||</div><div>        !_prefs.containsKey(kHasSyncedArchiveKey);</div><div>  }</div><div></div><div>  Future&lt;void&gt; _markResetSyncTimeAsDone() async {</div><div>    await _prefs.setBool(kHasSyncedArchiveKey, true);</div><div>    await _prefs.setBool(kHasSyncedEditTime, true);</div><div>    // Check to avoid regression because of change or additions of keys</div><div>    if (_shouldResetSyncTime()) {</div><div>      throw Exception(&quot;_shouldResetSyncTime should return false now&quot;);</div><div>    }</div><div>  }</div><div></div><div>  int _getSinceTimeForReSync() {</div><div>    // re-sync from archive feature time if the client still hasn&#039;t synced</div><div>    // since the feature release.</div><div>    if (!_prefs.containsKey(kHasSyncedArchiveKey)) {</div><div>      return kArchiveFeatureReleaseTime;</div><div>    }</div><div>    return kEditTimeFeatureReleaseTime;</div><div>  }</div><div></div><div>  bool get shouldThrottleUpload {</div><div>    return !Platform.isAndroid &amp;&amp; !AppLifecycleService.instance.isForeground;</div><div>  }</div><div></div><div>  bool get bgWithoutResumableUpload {</div><div>    // if multiple part is enabled, then we are not throttling uploads in bg</div><div>    return !(flagService.enableMobMultiPart &amp;&amp;</div><div>            localSettings.userEnabledMultiplePart) &amp;&amp;</div><div>        !AppLifecycleService.instance.isForeground;</div><div>  }</div><div></div><div>  // _sortByTime sort by creation time (desc).</div><div>  // This is done to upload most recent photo first.</div><div>  void _sortByTime(List&lt;EnteFile&gt; file) {</div><div>    file.sort((first, second) {</div><div>      // 1. fileType: move videos to end when in bg</div><div>      if (!AppLifecycleService.instance.isForeground &amp;&amp;</div><div>          first.fileType != second.fileType) {</div><div>        if (first.fileType == FileType.video) return 1;</div><div>        if (second.fileType == FileType.video) return -1;</div><div>      }</div><div></div><div>      // 2. creationTime descending</div><div>      return second.creationTime!.compareTo(first.creationTime!);</div><div>    });</div><div>  }</div><div></div><div>  bool _shouldShowNotification(int collectionID) {</div><div>    // TODO: Add option to opt out of notifications for a specific collection</div><div>    // Screen: https://www.figma.com/file/SYtMyLBs5SAOkTbfMMzhqt/ente-Visual-Design?type=design&amp;node-id=7689-52943&amp;t=IyWOfh0Gsb0p7yVC-4</div><div>    final isForeground = AppLifecycleService.instance.isForeground;</div><div>    final bool showNotification =</div><div>        NotificationService.instance.shouldShowNotificationsForSharedPhotos() &amp;&amp;</div><div>            isFirstRemoteSyncDone() &amp;&amp;</div><div>            !isForeground;</div><div>    _logger.info(</div><div>      &quot;[Collection-$collectionID] shouldShow notification: $showNotification, &quot;</div><div>      &quot;isAppInForeground: $isForeground&quot;,</div><div>    );</div><div>    return showNotification;</div><div>  }</div><div></div><div>  Future&lt;void&gt; _notifyNewFiles(List&lt;int&gt; collectionIDs) async {</div><div>    final userID = Configuration.instance.getUserID();</div><div>    final appOpenTime = AppLifecycleService.instance.getLastAppOpenTime();</div><div>    for (final collectionID in collectionIDs) {</div><div>      if (!_shouldShowNotification(collectionID)) {</div><div>        continue;</div><div>      }</div><div>      final files =</div><div>          await _db.getNewFilesInCollection(collectionID, appOpenTime);</div><div>      final Set&lt;int&gt; sharedFilesIDs = {};</div><div>      final Set&lt;int&gt; collectedFilesIDs = {};</div><div>      for (final file in files) {</div><div>        if (file.isUploaded &amp;&amp; file.ownerID != userID) {</div><div>          sharedFilesIDs.add(file.uploadedFileID!);</div><div>        } else if (file.isUploaded &amp;&amp; file.isCollect) {</div><div>          collectedFilesIDs.add(file.uploadedFileID!);</div><div>        }</div><div>      }</div><div>      final totalCount = sharedFilesIDs.length + collectedFilesIDs.length;</div><div>      if (totalCount &gt; 0) {</div><div>        final collection = _collectionsService.getCollectionByID(collectionID);</div><div>        _logger.info(</div><div>          &#039;creating notification for ${collection?.displayName} &#039;</div><div>          &#039;shared: $sharedFilesIDs, collected: $collectedFilesIDs files&#039;,</div><div>        );</div><div>        final s = await LanguageService.locals;</div><div>        // ignore: unawaited_futures</div><div>        NotificationService.instance.showNotification(</div><div>          collection!.displayName,</div><div>          totalCount.toString() + s.newPhotosEmoji,</div><div>          channelID: &quot;collection:&quot; + collectionID.toString(),</div><div>          channelName: collection.displayName,</div><div>          payload: &quot;ente://collection/?collectionID=&quot; + collectionID.toString(),</div><div>        );</div><div>      }</div><div>    }</div><div>  }</div><div>}</div><div></div></div></div></div><div class="assistant-text">Now let me look at the FileUploader class and how the queue is managed:</div><div class="tool-execution" style="background-color: rgb(40, 50, 40)"><div class="tool-command">$ find /Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib -name &quot;file_uploader*.dart&quot; | head -5</div><div class="tool-output"><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/utils/file_uploader_util.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/utils/file_uploader.dart</div></div></div><div class="tool-execution" style="background-color: rgb(40, 50, 40)"><div class="tool-command">$ grep -r &quot;removeFromQueueWhere\|onDeviceCollectionSet\|clearQueue&quot; /Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib --include=&quot;*.dart&quot; | head -20</div><div class="tool-output expandable" onclick="this.classList.toggle('expanded')"><div class="output-preview"><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/utils/file_uploader.dart:        removeFromQueueWhere(</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/utils/file_uploader.dart:  void clearQueue(final Error reason) {</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/utils/file_uploader.dart:  void removeFromQueueWhere(</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/utils/file_uploader.dart:      clearQueue(SyncStopRequestedError());</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/utils/file_uploader.dart:            clearQueue(error);</div><div class="expand-hint">... (10 more lines) - click to expand</div></div><div class="output-full"><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/utils/file_uploader.dart:        removeFromQueueWhere(</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/utils/file_uploader.dart:  void clearQueue(final Error reason) {</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/utils/file_uploader.dart:  void removeFromQueueWhere(</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/utils/file_uploader.dart:      clearQueue(SyncStopRequestedError());</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/utils/file_uploader.dart:            clearQueue(error);</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/utils/file_uploader.dart:            clearQueue(error);</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/utils/file_uploader.dart:    clearQueue(StorageLimitExceededError());</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/services/video_preview_service.dart:      clearQueue();</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/services/video_preview_service.dart:  void clearQueue() {</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/services/video_preview_service.dart:      clearQueue();</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/services/sync/remote_sync_service.dart:    SyncService.instance.onDeviceCollectionSet(newCollectionIDsForAutoSync);</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/services/sync/sync_service.dart:      _uploader.clearQueue(SilentlyCancelUploadsError());</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/services/sync/sync_service.dart:  void onDeviceCollectionSet(Set&lt;int&gt; collectionIDs) {</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/services/sync/sync_service.dart:    _uploader.removeFromQueueWhere(</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/services/sync/sync_service.dart:    _uploader.removeFromQueueWhere(</div></div></div></div><div class="tool-execution" style="background-color: rgb(40, 50, 40)"><div class="tool-header"><span class="tool-name">read</span> <span class="tool-path">~/dev/enteio/ente/mobile/apps/photos/lib/utils/file_uploader.dart</span></div><div class="tool-output expandable" onclick="this.classList.toggle('expanded')"><div class="output-preview"><div>import &#039;dart:async&#039;;</div><div>import &#039;dart:collection&#039;;</div><div>import &#039;dart:convert&#039;;</div><div>import &#039;dart:io&#039;;</div><div>import &#039;dart:math&#039; as math;</div><div></div><div>import &#039;package:collection/collection.dart&#039;;</div><div>import &#039;package:dio/dio.dart&#039;;</div><div>import &#039;package:ente_crypto/ente_crypto.dart&#039;;</div><div>import &#039;package:flutter/foundation.dart&#039;;</div><div class="expand-hint">... (1777 more lines) - click to expand</div></div><div class="output-full"><div>import &#039;dart:async&#039;;</div><div>import &#039;dart:collection&#039;;</div><div>import &#039;dart:convert&#039;;</div><div>import &#039;dart:io&#039;;</div><div>import &#039;dart:math&#039; as math;</div><div></div><div>import &#039;package:collection/collection.dart&#039;;</div><div>import &#039;package:dio/dio.dart&#039;;</div><div>import &#039;package:ente_crypto/ente_crypto.dart&#039;;</div><div>import &#039;package:flutter/foundation.dart&#039;;</div><div>import &#039;package:logging/logging.dart&#039;;</div><div>import &quot;package:path/path.dart&quot;;</div><div>import &quot;package:permission_handler/permission_handler.dart&quot;;</div><div>import &#039;package:photos/core/configuration.dart&#039;;</div><div>import &quot;package:photos/core/constants.dart&quot;;</div><div>import &#039;package:photos/core/errors.dart&#039;;</div><div>import &#039;package:photos/core/event_bus.dart&#039;;</div><div>import &#039;package:photos/core/network/network.dart&#039;;</div><div>import &#039;package:photos/db/files_db.dart&#039;;</div><div>import &#039;package:photos/db/upload_locks_db.dart&#039;;</div><div>import &quot;package:photos/events/backup_updated_event.dart&quot;;</div><div>import &quot;package:photos/events/file_uploaded_event.dart&quot;;</div><div>import &#039;package:photos/events/files_updated_event.dart&#039;;</div><div>import &#039;package:photos/events/local_photos_updated_event.dart&#039;;</div><div>import &#039;package:photos/events/subscription_purchased_event.dart&#039;;</div><div>import &quot;package:photos/extensions/logger_extension.dart&quot;;</div><div>import &quot;package:photos/main.dart&quot; show isProcessBg, kLastBGTaskHeartBeatTime;</div><div>import &quot;package:photos/models/api/metadata.dart&quot;;</div><div>import &quot;package:photos/models/backup/backup_item.dart&quot;;</div><div>import &quot;package:photos/models/backup/backup_item_status.dart&quot;;</div><div>import &#039;package:photos/models/file/file.dart&#039;;</div><div>import &#039;package:photos/models/file/file_type.dart&#039;;</div><div>import &quot;package:photos/models/metadata/file_magic.dart&quot;;</div><div>import &quot;package:photos/models/user_details.dart&quot;;</div><div>import &#039;package:photos/module/upload/model/upload_url.dart&#039;;</div><div>import &quot;package:photos/module/upload/service/multipart.dart&quot;;</div><div>import &quot;package:photos/service_locator.dart&quot;;</div><div>import &quot;package:photos/services/account/user_service.dart&quot;;</div><div>import &#039;package:photos/services/collections_service.dart&#039;;</div><div>import &#039;package:photos/services/sync/local_sync_service.dart&#039;;</div><div>import &#039;package:photos/services/sync/sync_service.dart&#039;;</div><div>import &quot;package:photos/utils/exif_util.dart&quot;;</div><div>import &quot;package:photos/utils/file_key.dart&quot;;</div><div>import &#039;package:photos/utils/file_uploader_util.dart&#039;;</div><div>import &quot;package:photos/utils/file_util.dart&quot;;</div><div>import &quot;package:photos/utils/network_util.dart&quot;;</div><div>import &#039;package:photos/utils/standalone/data.dart&#039;;</div><div>import &#039;package:shared_preferences/shared_preferences.dart&#039;;</div><div>import &#039;package:tuple/tuple.dart&#039;;</div><div>import &quot;package:uuid/uuid.dart&quot;;</div><div></div><div>class FileUploader {</div><div>  static const kMaximumConcurrentUploads = 4;</div><div>  static const kMaximumConcurrentVideoUploads = 2;</div><div>  static const kMaximumThumbnailCompressionAttempts = 2;</div><div>  static const kMaximumUploadAttempts = 4;</div><div>  static const kMaxFileSize10Gib = 10737418240;</div><div>  static const kBlockedUploadsPollFrequency = Duration(seconds: 2);</div><div>  static const kFileUploadTimeout = Duration(minutes: 50);</div><div>  static const k20MBStorageBuffer = 20 * 1024 * 1024;</div><div>  static const _lastStaleFileCleanupTime = &quot;lastStaleFileCleanupTime&quot;;</div><div></div><div>  final _logger = Logger(&quot;FileUploader&quot;);</div><div>  final _dio = NetworkClient.instance.getDio();</div><div>  final _enteDio = NetworkClient.instance.enteDio;</div><div>  final LinkedHashMap&lt;String, FileUploadItem&gt; _queue =</div><div>      LinkedHashMap&lt;String, FileUploadItem&gt;();</div><div>  final LinkedHashMap&lt;String, BackupItem&gt; _allBackups =</div><div>      LinkedHashMap&lt;String, BackupItem&gt;();</div><div>  final _uploadLocks = UploadLocksDB.instance;</div><div>  final kSafeBufferForLockExpiry = const Duration(hours: 4).inMicroseconds;</div><div>  final kBGTaskDeathTimeout = const Duration(seconds: 5).inMicroseconds;</div><div>  final _uploadURLs = Queue&lt;UploadURL&gt;();</div><div></div><div>  // Track used upload URLs to detect race conditions</div><div>  final Map&lt;String, DateTime&gt; _usedUploadURLs = {};</div><div></div><div>  LinkedHashMap&lt;String, BackupItem&gt; get allBackups =&gt; _allBackups;</div><div></div><div>  // Maintains the count of files in the current upload session.</div><div>  // Upload session is the period between the first entry into the _queue and last entry out of the _queue</div><div>  int _totalCountInUploadSession = 0;</div><div></div><div>  // _uploadCounter indicates number of uploads which are currently in progress</div><div>  int _uploadCounter = 0;</div><div>  int _videoUploadCounter = 0;</div><div>  late ProcessType _processType;</div><div>  late SharedPreferences _prefs;</div><div></div><div>  // _hasInitiatedForceUpload is used to track if user attempted force upload</div><div>  // where files are uploaded directly (without adding them to DB). In such</div><div>  // cases, we don&#039;t want to clear the stale upload files. See #removeStaleFiles</div><div>  // as it can result in clearing files which are still being force uploaded.</div><div>  bool _hasInitiatedForceUpload = false;</div><div>  late MultiPartUploader _multiPartUploader;</div><div></div><div>  FileUploader._privateConstructor() {</div><div>    Bus.instance.on&lt;SubscriptionPurchasedEvent&gt;().listen((event) {</div><div>      _uploadURLFetchInProgress = null;</div><div>    });</div><div>  }</div><div></div><div>  static FileUploader instance = FileUploader._privateConstructor();</div><div></div><div>  Future&lt;void&gt; init(SharedPreferences preferences, bool isBackground) async {</div><div>    _prefs = preferences;</div><div>    _processType =</div><div>        isBackground ? ProcessType.background : ProcessType.foreground;</div><div>    final currentTime = DateTime.now().microsecondsSinceEpoch;</div><div>    await _uploadLocks.releaseLocksAcquiredByOwnerBefore(</div><div>      _processType.toString(),</div><div>      currentTime,</div><div>    );</div><div>    await _uploadLocks</div><div>        .releaseAllLocksAcquiredBefore(currentTime - kSafeBufferForLockExpiry);</div><div>    if (!isBackground) {</div><div>      await _prefs.reload();</div><div>      final lastBGTaskHeartBeatTime =</div><div>          _prefs.getInt(kLastBGTaskHeartBeatTime) ?? 0;</div><div>      final isBGTaskDead =</div><div>          lastBGTaskHeartBeatTime &lt; (currentTime - kBGTaskDeathTimeout);</div><div>      if (isBGTaskDead) {</div><div>        await _uploadLocks.releaseLocksAcquiredByOwnerBefore(</div><div>          ProcessType.background.toString(),</div><div>          currentTime,</div><div>        );</div><div>        _logger.info(&quot;BG task was found dead, cleared all locks&quot;);</div><div>      } else {</div><div>        _logger.info(</div><div>          &quot;BG task is alive, not clearing locks ${DateTime.fromMicrosecondsSinceEpoch(lastBGTaskHeartBeatTime)}&quot;,</div><div>        );</div><div>      }</div><div>      // ignore: unawaited_futures</div><div>      _pollBackgroundUploadStatus();</div><div>    }</div><div>    _multiPartUploader = MultiPartUploader(</div><div>      _enteDio,</div><div>      _dio,</div><div>      UploadLocksDB.instance,</div><div>      flagService,</div><div>    );</div><div>    if (currentTime - (_prefs.getInt(_lastStaleFileCleanupTime) ?? 0) &gt;</div><div>        tempDirCleanUpInterval) {</div><div>      await removeStaleFiles();</div><div>      await _prefs.setInt(_lastStaleFileCleanupTime, currentTime);</div><div>    }</div><div>    Bus.instance.on&lt;LocalPhotosUpdatedEvent&gt;().listen((event) {</div><div>      if (event.type == EventType.deletedFromDevice ||</div><div>          event.type == EventType.deletedFromEverywhere) {</div><div>        removeFromQueueWhere(</div><div>          (file) {</div><div>            for (final updatedFile in event.updatedFiles) {</div><div>              if (file.generatedID == updatedFile.generatedID) {</div><div>                return true;</div><div>              }</div><div>            }</div><div>            return false;</div><div>          },</div><div>          InvalidFileError(</div><div>            &quot;File already deleted&quot;,</div><div>            InvalidReason.assetDeletedEvent,</div><div>          ),</div><div>        );</div><div>      }</div><div>    });</div><div>  }</div><div></div><div>  // upload future will return null as File when the file entry is deleted</div><div>  // locally because it&#039;s already present in the destination collection.</div><div>  Future&lt;EnteFile&gt; upload(EnteFile file, int collectionID) {</div><div>    _logger.internalInfo(</div><div>      &quot;[UPLOAD-DEBUG] FileUploader.upload() called for ${file.title} &quot;</div><div>      &quot;(localID: ${file.localID}, collectionID: $collectionID, &quot;</div><div>      &quot;isProcessBg: $isProcessBg)&quot;,</div><div>    );</div><div></div><div>    if (file.localID == null || file.localID!.isEmpty) {</div><div>      _logger.internalSevere(</div><div>        &quot;[UPLOAD-DEBUG] Upload rejected - file&#039;s localID is null or empty for ${file.title}&quot;,</div><div>      );</div><div>      return Future.error(Exception(&quot;file&#039;s localID can not be null or empty&quot;));</div><div>    }</div><div>    // If the file hasn&#039;t been queued yet, queue it for upload</div><div>    _totalCountInUploadSession++;</div><div>    final String localID = file.localID!;</div><div>    if (!_queue.containsKey(localID)) {</div><div>      _logger.internalInfo(</div><div>        &quot;[UPLOAD-DEBUG] File ${file.title} not in queue. Adding to upload queue... &quot;</div><div>        &quot;(queue size before: ${_queue.length})&quot;,</div><div>      );</div><div>      final completer = Completer&lt;EnteFile&gt;();</div><div>      _queue[localID] = FileUploadItem(file, collectionID, completer);</div><div>      _allBackups[localID] = BackupItem(</div><div>        status: BackupItemStatus.inQueue,</div><div>        file: file,</div><div>        collectionID: collectionID,</div><div>        completer: completer,</div><div>      );</div><div>      Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>      _logger.internalInfo(</div><div>        &quot;[UPLOAD-DEBUG] File ${file.title} added to queue (queue size: ${_queue.length}). &quot;</div><div>        &quot;Calling _pollQueue()...&quot;,</div><div>      );</div><div>      _pollQueue();</div><div>      _logger.internalInfo(</div><div>        &quot;[UPLOAD-DEBUG] _pollQueue() called for ${file.title}. Returning completer.future&quot;,</div><div>      );</div><div>      return completer.future;</div><div>    }</div><div>    // If the file exists in the queue for a matching collectionID,</div><div>    // return the existing future</div><div>    _logger.internalInfo(</div><div>      &quot;[UPLOAD-DEBUG] File ${file.title} already in queue with localID $localID&quot;,</div><div>    );</div><div>    final FileUploadItem item = _queue[localID]!;</div><div>    if (item.collectionID == collectionID) {</div><div>      _totalCountInUploadSession--;</div><div>      _logger.internalInfo(</div><div>        &quot;[UPLOAD-DEBUG] Same collectionID ($collectionID) - returning existing future&quot;,</div><div>      );</div><div>      return item.completer.future;</div><div>    }</div><div>    _logger.internalInfo(</div><div>      &quot;[UPLOAD-DEBUG] Different collectionID (existing: ${item.collectionID}, new: $collectionID) &quot;</div><div>      &quot;- waiting for existing upload to complete&quot;,</div><div>    );</div><div>    debugPrint(</div><div>      &quot;Wait on another upload on same local ID to finish before &quot;</div><div>      &quot;adding it to new collection&quot;,</div><div>    );</div><div>    // Else wait for the existing upload to complete,</div><div>    // and add it to the relevant collection</div><div>    return item.completer.future.then((uploadedFile) {</div><div>      // If the fileUploader completer returned null,</div><div>      _logger.info(</div><div>        &quot;original upload completer resolved, try adding the file to another &quot;</div><div>        &quot;collection&quot;,</div><div>      );</div><div></div><div>      return CollectionsService.instance</div><div>          .addOrCopyToCollection(collectionID, [uploadedFile]).then((aVoid) {</div><div>        return uploadedFile;</div><div>      });</div><div>    });</div><div>  }</div><div></div><div>  int getCurrentSessionUploadCount() {</div><div>    return _totalCountInUploadSession;</div><div>  }</div><div></div><div>  void clearQueue(final Error reason) {</div><div>    final List&lt;String&gt; uploadsToBeRemoved = [];</div><div>    _queue.entries</div><div>        .where((entry) =&gt; entry.value.status == UploadStatus.notStarted)</div><div>        .forEach((pendingUpload) {</div><div>      uploadsToBeRemoved.add(pendingUpload.key);</div><div>    });</div><div>    for (final id in uploadsToBeRemoved) {</div><div>      _queue.remove(id)?.completer.completeError(reason);</div><div>      _allBackups[id] = _allBackups[id]!.copyWith(</div><div>        status: BackupItemStatus.retry,</div><div>        error: reason,</div><div>      );</div><div>      Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>    }</div><div>    _totalCountInUploadSession = 0;</div><div>  }</div><div></div><div>  void clearCachedUploadURLs() {</div><div>    _uploadURLs.clear();</div><div>    _usedUploadURLs.clear();</div><div>    _logger.info(&quot;Cleared upload URL cache and usage tracking&quot;);</div><div>  }</div><div></div><div>  void removeFromQueueWhere(</div><div>    final bool Function(EnteFile) fn,</div><div>    final Error reason,</div><div>  ) {</div><div>    final List&lt;String&gt; uploadsToBeRemoved = [];</div><div>    _queue.entries</div><div>        .where((entry) =&gt; entry.value.status == UploadStatus.notStarted)</div><div>        .forEach((pendingUpload) {</div><div>      if (fn(pendingUpload.value.file)) {</div><div>        uploadsToBeRemoved.add(pendingUpload.key);</div><div>      }</div><div>    });</div><div>    for (final id in uploadsToBeRemoved) {</div><div>      _queue.remove(id)?.completer.completeError(reason);</div><div>      _allBackups[id] = _allBackups[id]!</div><div>          .copyWith(status: BackupItemStatus.retry, error: reason);</div><div>      Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>    }</div><div>    _logger.info(</div><div>      &#039;number of enteries removed from queue ${uploadsToBeRemoved.length}&#039;,</div><div>    );</div><div>    _totalCountInUploadSession -= uploadsToBeRemoved.length;</div><div>  }</div><div></div><div>  void _pollQueue() {</div><div>    _logger.internalInfo(</div><div>      &quot;[UPLOAD-DEBUG] _pollQueue() called. Queue size: ${_queue.length}, &quot;</div><div>      &quot;uploadCounter: $_uploadCounter/$kMaximumConcurrentUploads, &quot;</div><div>      &quot;isProcessBg: $isProcessBg&quot;,</div><div>    );</div><div></div><div>    if (SyncService.instance.shouldStopSync()) {</div><div>      _logger.internalWarning(</div><div>        &quot;[UPLOAD-DEBUG] Sync stop requested - clearing queue&quot;,</div><div>      );</div><div>      clearQueue(SyncStopRequestedError());</div><div>      return;</div><div>    }</div><div>    if (_queue.isEmpty) {</div><div>      // Upload session completed</div><div>      _logger.internalInfo(</div><div>        &quot;[UPLOAD-DEBUG] Queue is empty - upload session completed. &quot;</div><div>        &quot;Resetting totalCountInUploadSession&quot;,</div><div>      );</div><div>      _totalCountInUploadSession = 0;</div><div>      return;</div><div>    }</div><div>    if (_uploadCounter &lt; kMaximumConcurrentUploads) {</div><div>      _logger.internalInfo(</div><div>        &quot;[UPLOAD-DEBUG] Upload capacity available ($_uploadCounter &lt; $kMaximumConcurrentUploads). &quot;</div><div>        &quot;Searching for pending entry...&quot;,</div><div>      );</div><div>      var pendingEntry = _queue.entries</div><div>          .firstWhereOrNull(</div><div>            (entry) =&gt; entry.value.status == UploadStatus.notStarted,</div><div>          )</div><div>          ?.value;</div><div></div><div>      if (pendingEntry != null) {</div><div>        _logger.internalInfo(</div><div>          &quot;[UPLOAD-DEBUG] Found pending entry: ${pendingEntry.file.title} &quot;</div><div>          &quot;(fileType: ${pendingEntry.file.fileType})&quot;,</div><div>        );</div><div>      } else {</div><div>        _logger.internalInfo(&quot;[UPLOAD-DEBUG] No pending entry found in queue&quot;);</div><div>      }</div><div></div><div>      if (pendingEntry != null &amp;&amp;</div><div>          pendingEntry.file.fileType == FileType.video &amp;&amp;</div><div>          _videoUploadCounter &gt;= kMaximumConcurrentVideoUploads) {</div><div>        _logger.internalInfo(</div><div>          &quot;[UPLOAD-DEBUG] Video upload limit reached ($_videoUploadCounter &gt;= $kMaximumConcurrentVideoUploads). &quot;</div><div>          &quot;Looking for non-video entry...&quot;,</div><div>        );</div><div>        // check if there&#039;s any non-video entry which can be queued for upload</div><div>        pendingEntry = _queue.entries</div><div>            .firstWhereOrNull(</div><div>              (entry) =&gt;</div><div>                  entry.value.status == UploadStatus.notStarted &amp;&amp;</div><div>                  entry.value.file.fileType != FileType.video,</div><div>            )</div><div>            ?.value;</div><div>        if (pendingEntry != null) {</div><div>          _logger.internalInfo(</div><div>            &quot;[UPLOAD-DEBUG] Found non-video entry: ${pendingEntry.file.title}&quot;,</div><div>          );</div><div>        } else {</div><div>          _logger.internalInfo(&quot;[UPLOAD-DEBUG] No non-video entry available&quot;);</div><div>        }</div><div>      }</div><div>      if (pendingEntry != null) {</div><div>        _logger.internalInfo(</div><div>          &quot;[UPLOAD-DEBUG] Starting upload for ${pendingEntry.file.title}. &quot;</div><div>          &quot;Marking as inProgress and calling _encryptAndUploadFileToCollection()...&quot;,</div><div>        );</div><div>        pendingEntry.status = UploadStatus.inProgress;</div><div>        _allBackups[pendingEntry.file.localID!] =</div><div>            _allBackups[pendingEntry.file.localID]!</div><div>                .copyWith(status: BackupItemStatus.uploading);</div><div>        Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>        _encryptAndUploadFileToCollection(</div><div>          pendingEntry.file,</div><div>          pendingEntry.collectionID,</div><div>        );</div><div>        _logger.internalInfo(</div><div>          &quot;[UPLOAD-DEBUG] _encryptAndUploadFileToCollection() initiated for ${pendingEntry.file.title}&quot;,</div><div>        );</div><div>      } else {</div><div>        _logger.internalInfo(</div><div>          &quot;[UPLOAD-DEBUG] No pending entry to process at this time &quot;</div><div>          &quot;(either all uploads in progress or video limit reached)&quot;,</div><div>        );</div><div>      }</div><div>    } else {</div><div>      _logger.internalInfo(</div><div>        &quot;[UPLOAD-DEBUG] Upload capacity full ($_uploadCounter &gt;= $kMaximumConcurrentUploads). &quot;</div><div>        &quot;Waiting for uploads to complete...&quot;,</div><div>      );</div><div>    }</div><div>  }</div><div></div><div>  Future&lt;EnteFile?&gt; _encryptAndUploadFileToCollection(</div><div>    EnteFile file,</div><div>    int collectionID, {</div><div>    bool forcedUpload = false,</div><div>  }) async {</div><div>    _logger.internalInfo(</div><div>      &quot;[UPLOAD-DEBUG] _encryptAndUploadFileToCollection() started for ${file.title} &quot;</div><div>      &quot;(collectionID: $collectionID, forcedUpload: $forcedUpload, &quot;</div><div>      &quot;isProcessBg: $isProcessBg)&quot;,</div><div>    );</div><div>    _uploadCounter++;</div><div>    if (file.fileType == FileType.video) {</div><div>      _videoUploadCounter++;</div><div>    }</div><div>    _logger.internalInfo(</div><div>      &quot;[UPLOAD-DEBUG] Upload counters updated: uploadCounter=$_uploadCounter, &quot;</div><div>      &quot;videoUploadCounter=$_videoUploadCounter&quot;,</div><div>    );</div><div>    final localID = file.localID!;</div><div>    try {</div><div>      _logger.internalInfo(</div><div>        &quot;[UPLOAD-DEBUG] Calling _tryToUpload() for ${file.title} with ${kFileUploadTimeout.inSeconds}s timeout...&quot;,</div><div>      );</div><div>      final uploadedFile =</div><div>          await _tryToUpload(file, collectionID, forcedUpload).timeout(</div><div>        kFileUploadTimeout,</div><div>        onTimeout: () {</div><div>          final message = &quot;Upload timed out for file &quot; + file.toString();</div><div>          _logger.internalWarning(&quot;[UPLOAD-DEBUG] $message&quot;);</div><div>          throw TimeoutException(message);</div><div>        },</div><div>      );</div><div>      _logger.internalInfo(</div><div>        &quot;[UPLOAD-DEBUG] _tryToUpload() completed successfully for ${file.title}&quot;,</div><div>      );</div><div>      _queue.remove(localID)!.completer.complete(uploadedFile);</div><div>      _allBackups[localID] =</div><div>          _allBackups[localID]!.copyWith(status: BackupItemStatus.uploaded);</div><div>      Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>      return uploadedFile;</div><div>    } catch (e) {</div><div>      if (e is LockAlreadyAcquiredError) {</div><div>        _queue[localID]!.status = UploadStatus.inBackground;</div><div>        _allBackups[localID] = _allBackups[localID]!</div><div>            .copyWith(status: BackupItemStatus.inBackground);</div><div>        Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>        return _queue[localID]!.completer.future;</div><div>      } else {</div><div>        _queue.remove(localID)!.completer.completeError(e);</div><div>        _allBackups[localID] = _allBackups[localID]!</div><div>            .copyWith(status: BackupItemStatus.retry, error: e);</div><div>        Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>        return null;</div><div>      }</div><div>    } finally {</div><div>      _uploadCounter--;</div><div>      if (file.fileType == FileType.video) {</div><div>        _videoUploadCounter--;</div><div>      }</div><div>      _pollQueue();</div><div>    }</div><div>  }</div><div></div><div>  Future&lt;void&gt; removeStaleFiles() async {</div><div>    if (_hasInitiatedForceUpload) {</div><div>      _logger.info(</div><div>        &quot;Force upload was initiated, skipping stale file cleanup&quot;,</div><div>      );</div><div>      return;</div><div>    }</div><div>    try {</div><div>      final String dir = Configuration.instance.getTempDirectory();</div><div>      // delete all files in the temp directory that start with upload_ and</div><div>      // ends with .encrypted. Fetch files in async manner</div><div>      final files = await Directory(dir).list().toList();</div><div>      final filesToDelete = files.where((file) {</div><div>        return file.path.contains(uploadTempFilePrefix) &amp;&amp;</div><div>            file.path.contains(&quot;.encrypted&quot;);</div><div>      });</div><div>      if (filesToDelete.isNotEmpty) {</div><div>        _logger.info(&#039;Deleting ${filesToDelete.length} stale upload files &#039;);</div><div>        final fileNameToLastAttempt =</div><div>            await _uploadLocks.getFileNameToLastAttemptedAtMap();</div><div>        for (final file in filesToDelete) {</div><div>          final fileName = file.path.split(&#039;/&#039;).last;</div><div>          final lastAttemptTime = fileNameToLastAttempt[fileName] != null</div><div>              ? DateTime.fromMillisecondsSinceEpoch(</div><div>                  fileNameToLastAttempt[fileName]!,</div><div>                )</div><div>              : null;</div><div>          if (lastAttemptTime == null ||</div><div>              DateTime.now().difference(lastAttemptTime).inDays &gt; 1) {</div><div>            await file.delete();</div><div>          } else {</div><div>            _logger.info(</div><div>              &#039;Skipping file $fileName as it was attempted recently on $lastAttemptTime&#039;,</div><div>            );</div><div>          }</div><div>        }</div><div>      }</div><div></div><div>      if (Platform.isAndroid) {</div><div>        final sharedMediaDir =</div><div>            Configuration.instance.getSharedMediaDirectory() + &quot;/&quot;;</div><div>        final sharedFiles = await Directory(sharedMediaDir).list().toList();</div><div>        if (sharedFiles.isNotEmpty) {</div><div>          _logger.info(&#039;Shared media directory cleanup ${sharedFiles.length}&#039;);</div><div>          final int ownerID = Configuration.instance.getUserID()!;</div><div>          final existingLocalFileIDs =</div><div>              await FilesDB.instance.getExistingLocalFileIDs(ownerID);</div><div>          final Set&lt;String&gt; trackedSharedFilePaths = {};</div><div>          for (String localID in existingLocalFileIDs) {</div><div>            if (localID.contains(sharedMediaIdentifier)) {</div><div>              trackedSharedFilePaths</div><div>                  .add(getSharedMediaPathFromLocalID(localID));</div><div>            }</div><div>          }</div><div>          for (final file in sharedFiles) {</div><div>            if (!trackedSharedFilePaths.contains(file.path)) {</div><div>              _logger.info(&#039;Deleting stale shared media file ${file.path}&#039;);</div><div>              await file.delete();</div><div>            }</div><div>          }</div><div>        }</div><div>      }</div><div>    } catch (e, s) {</div><div>      _logger.severe(&quot;Failed to remove stale files&quot;, e, s);</div><div>    }</div><div>  }</div><div></div><div>  Future&lt;void&gt; checkNetworkForUpload({bool isForceUpload = false}) async {</div><div>    // Note: We don&#039;t support force uploading currently. During force upload,</div><div>    // network check is skipped completely</div><div>    if (isForceUpload) {</div><div>      return;</div><div>    }</div><div>    final canUploadUnderCurrentNetworkConditions = await canUseHighBandwidth();</div><div></div><div>    if (!canUploadUnderCurrentNetworkConditions) {</div><div>      throw WiFiUnavailableError();</div><div>    }</div><div>  }</div><div></div><div>  Future&lt;void&gt; verifyMediaLocationAccess() async {</div><div>    if (Platform.isAndroid) {</div><div>      final bool hasPermission = await Permission.accessMediaLocation.isGranted;</div><div>      if (!hasPermission) {</div><div>        // In background isolate, we can&#039;t request permissions (no UI available)</div><div>        // Throw an error to properly handle this scenario</div><div>        if (isProcessBg) {</div><div>          _logger.severe(</div><div>            &quot;Media location access not granted in background isolate - cannot request permission&quot;,</div><div>          );</div><div>          throw NoMediaLocationAccessError();</div><div>        }</div><div>        // Only request permission in foreground</div><div>        final permissionStatus = await Permission.accessMediaLocation.request();</div><div>        if (!permissionStatus.isGranted) {</div><div>          _logger.severe(</div><div>            &quot;Media location access denied with permission status: ${permissionStatus.name}&quot;,</div><div>          );</div><div>          throw NoMediaLocationAccessError();</div><div>        }</div><div>      }</div><div>    }</div><div>  }</div><div></div><div>  Future&lt;EnteFile&gt; forceUpload(EnteFile file, int collectionID) async {</div><div>    _hasInitiatedForceUpload = true;</div><div>    final isInQueue = _allBackups[file.localID!] != null;</div><div>    try {</div><div>      final result = await _tryToUpload(file, collectionID, true);</div><div>      if (isInQueue) {</div><div>        _allBackups[file.localID!] = _allBackups[file.localID]!.copyWith(</div><div>          status: BackupItemStatus.uploaded,</div><div>        );</div><div>        Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>      }</div><div>      return result;</div><div>    } catch (error) {</div><div>      if (isInQueue) {</div><div>        _allBackups[file.localID!] = _allBackups[file.localID]!.copyWith(</div><div>          status: BackupItemStatus.retry,</div><div>          error: error,</div><div>        );</div><div>        Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>      }</div><div>      rethrow;</div><div>    }</div><div>  }</div><div></div><div>  Future&lt;EnteFile&gt; _tryToUpload(</div><div>    EnteFile file,</div><div>    int collectionID,</div><div>    bool forcedUpload,</div><div>  ) async {</div><div>    await checkNetworkForUpload(isForceUpload: forcedUpload);</div><div>    if (!forcedUpload) {</div><div>      final fileOnDisk = await FilesDB.instance.getFile(file.generatedID!);</div><div>      final wasAlreadyUploaded = fileOnDisk != null &amp;&amp;</div><div>          fileOnDisk.uploadedFileID != null &amp;&amp;</div><div>          (fileOnDisk.updationTime ?? -1) != -1 &amp;&amp;</div><div>          (fileOnDisk.collectionID ?? -1) == collectionID;</div><div>      if (wasAlreadyUploaded) {</div><div>        _logger.info(&quot;File is already uploaded ${fileOnDisk.tag}&quot;);</div><div>        return fileOnDisk;</div><div>      }</div><div>    }</div><div></div><div>    if (_allBackups[file.localID!] != null &amp;&amp;</div><div>        _allBackups[file.localID]!.status != BackupItemStatus.uploading) {</div><div>      _allBackups[file.localID!] = _allBackups[file.localID]!.copyWith(</div><div>        status: BackupItemStatus.uploading,</div><div>      );</div><div>      Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>    }</div><div>    if ((file.localID ?? &#039;&#039;) == &#039;&#039;) {</div><div>      _logger.severe(&#039;Trying to upload file with missing localID&#039;);</div><div>      return file;</div><div>    }</div><div>    if (!CollectionsService.instance.allowUpload(collectionID)) {</div><div>      _logger.warning(</div><div>        &#039;Upload not allowed for collection $collectionID&#039;,</div><div>      );</div><div>      if (!file.isUploaded &amp;&amp; file.generatedID != null) {</div><div>        _logger.info(&quot;Deleting file entry for &quot; + file.toString());</div><div>        await FilesDB.instance.deleteByGeneratedID(file.generatedID!);</div><div>      }</div><div>      return file;</div><div>    }</div><div></div><div>    final String lockKey = file.localID!;</div><div>    bool isMultipartUpload = false;</div><div></div><div>    try {</div><div>      await _uploadLocks.acquireLock(</div><div>        lockKey,</div><div>        _processType.toString(),</div><div>        DateTime.now().microsecondsSinceEpoch,</div><div>      );</div><div>    } catch (e) {</div><div>      final lockInfo = await _uploadLocks.getLockData(lockKey);</div><div>      _logger.warning(&quot;Lock was already taken ($lockInfo) for &quot; + file.tag);</div><div>      throw LockAlreadyAcquiredError();</div><div>    }</div><div></div><div>    MediaUploadData? mediaUploadData;</div><div>    try {</div><div>      mediaUploadData = await getUploadDataFromEnteFile(file, parseExif: true);</div><div>    } catch (e) {</div><div>      // This additional try catch block is added because for resumable upload,</div><div>      // we need to compute the hash before the next step. Previously, this</div><div>      // was done in during the upload itself.</div><div>      if (e is InvalidFileError) {</div><div>        _logger.severe(&quot;File upload ignored for &quot; + file.toString(), e);</div><div>        await _onInvalidFileError(file, e);</div><div>      }</div><div>      await _uploadLocks.releaseLock(lockKey, _processType.toString());</div><div>      rethrow;</div><div>    }</div><div></div><div>    final String? existingMultipartEncFileName =</div><div>        mediaUploadData.hashData?.fileHash != null</div><div>            ? await _uploadLocks.getEncryptedFileName(</div><div>                lockKey,</div><div>                mediaUploadData.hashData!.fileHash!,</div><div>                collectionID,</div><div>              )</div><div>            : null;</div><div>    final sourceLength = await mediaUploadData.sourceFile!.length();</div><div>    final bool hasExistingMultiPart = existingMultipartEncFileName != null;</div><div>    final tempDirectory = Configuration.instance.getTempDirectory();</div><div>    final String uniqueID =</div><div>        &#039;${const Uuid().v4().toString()}_${file.generatedID}&#039;;</div><div></div><div>    final encryptedFilePath = hasExistingMultiPart</div><div>        ? &#039;$tempDirectory$existingMultipartEncFileName&#039;</div><div>        : &#039;$tempDirectory$uploadTempFilePrefix${uniqueID}_file.encrypted&#039;;</div><div>    final encryptedThumbnailPath =</div><div>        &#039;$tempDirectory$uploadTempFilePrefix${uniqueID}_thumb.encrypted&#039;;</div><div>    late final int encFileSize;</div><div>    late final int encThumbSize;</div><div></div><div>    var uploadCompleted = false;</div><div>    // This flag is used to decide whether to clear the iOS origin file cache</div><div>    // or not.</div><div>    var uploadHardFailure = false;</div><div></div><div>    try {</div><div>      final bool isUpdatedFile =</div><div>          file.uploadedFileID != null &amp;&amp; file.updationTime == -1;</div><div>      _logger.info(</div><div>        &#039;starting ${forcedUpload ? &#039;forced&#039; : &#039;&#039;} &#039;</div><div>        &#039;${isUpdatedFile ? &#039;re-upload&#039; : &#039;upload&#039;} of ${file.toString()}&#039;,</div><div>      );</div><div></div><div>      Uint8List? key;</div><div>      final FileEncryptResult? multiPartFileEncResult = hasExistingMultiPart</div><div>          ? await _multiPartUploader.getEncryptionResult(</div><div>              lockKey,</div><div>              mediaUploadData.hashData!.fileHash!,</div><div>              collectionID,</div><div>              existingMultipartEncFileName,</div><div>            )</div><div>          : null;</div><div>      if (isUpdatedFile) {</div><div>        key = getFileKey(file);</div><div>      } else {</div><div>        key = multiPartFileEncResult?.key;</div><div>        // check if the file is already uploaded and can be mapped to existing</div><div>        // uploaded file. If map is found, it also returns the corresponding</div><div>        // mapped or update file entry.</div><div>        final result = await _mapToExistingUploadWithSameHash(</div><div>          mediaUploadData,</div><div>          file,</div><div>          collectionID,</div><div>        );</div><div>        final isMappedToExistingUpload = result.item1;</div><div>        if (isMappedToExistingUpload) {</div><div>          debugPrint(</div><div>            &quot;File success mapped to existing uploaded ${file.toString()}&quot;,</div><div>          );</div><div>          // return the mapped file</div><div>          return result.item2;</div><div>        }</div><div>      }</div><div></div><div>      final encryptedFileExists = File(encryptedFilePath).existsSync();</div><div></div><div>      // If the multipart entry exists but the encrypted file doesn&#039;t, it means</div><div>      // that we&#039;ll have to re-upload as the nonce is lost</div><div>      if (hasExistingMultiPart) {</div><div>        if (!encryptedFileExists) {</div><div>          throw MultiPartFileMissingError(</div><div>            &#039;multiPartResume: encryptedFile missing&#039;,</div><div>          );</div><div>        }</div><div>        final bool updateWithDiffKey = isUpdatedFile &amp;&amp;</div><div>            multiPartFileEncResult != null &amp;&amp;</div><div>            !listEquals(key, multiPartFileEncResult.key);</div><div>        if (updateWithDiffKey) {</div><div>          throw MultiPartError(</div><div>            &#039;multiPart update resumed with differentKey&#039;,</div><div>          );</div><div>        }</div><div>      } else if (encryptedFileExists) {</div><div>        // otherwise just delete the file for singlepart upload</div><div>        _logger.severe(&#039;File exists without multipart entry, deleting file&#039;);</div><div>        await File(encryptedFilePath).delete();</div><div>      }</div><div>      await _checkIfWithinStorageLimit(mediaUploadData.sourceFile!);</div><div>      final encryptedFile = File(encryptedFilePath);</div><div></div><div>      // Calculate the number of parts to determine if we need MD5</div><div>      // Use source length to estimate encrypted size for part count decision</div><div>      final estimatedEncSize = CryptoUtil.estimateEncryptedSize(sourceLength);</div><div>      final estimatedCount =</div><div>          _multiPartUploader.calculatePartCount(estimatedEncSize);</div><div></div><div>      FileEncryptResult? fileAttributes = multiPartFileEncResult;</div><div>      String? fileMd5;</div><div>      List&lt;String&gt;? partMd5s;</div><div></div><div>      if (fileAttributes == null) {</div><div>        final result = flagService.enableUploadV2</div><div>            ? (await CryptoUtil.encryptFileWithMD5(</div><div>                mediaUploadData.sourceFile!.path,</div><div>                encryptedFilePath,</div><div>                key: key,</div><div>                multiPartChunkSizeInBytes: (estimatedCount &gt; 1)</div><div>                    ? _multiPartUploader.multipartPartSizeForUpload</div><div>                    : null,</div><div>              ))</div><div>            : (await CryptoUtil.encryptFile(</div><div>                mediaUploadData.sourceFile!.path,</div><div>                encryptedFilePath,</div><div>                key: key,</div><div>              ));</div><div>        fileAttributes = result;</div><div>        fileMd5 = result.fileMd5;</div><div>        partMd5s = result.partMd5s;</div><div>      }</div><div></div><div>      late final Uint8List? thumbnailData;</div><div>      if (mediaUploadData.thumbnail == null &amp;&amp;</div><div>          file.fileType == FileType.video) {</div><div>        thumbnailData = base64Decode(blackThumbnailBase64);</div><div>      } else {</div><div>        thumbnailData = mediaUploadData.thumbnail;</div><div>      }</div><div>      encFileSize = await encryptedFile.length();</div><div>      if (!CryptoUtil.validateStreamEncryptionSizes(</div><div>        sourceLength,</div><div>        encFileSize,</div><div>      )) {</div><div>        throw EncSizeMismatchError(&quot;source $sourceLength, enc $encFileSize&quot;);</div><div>      }</div><div></div><div>      final EncryptionResult encryptedThumbnailData =</div><div>          await CryptoUtil.encryptChaCha(</div><div>        thumbnailData!,</div><div>        fileAttributes.key,</div><div>      );</div><div>      if (File(encryptedThumbnailPath).existsSync()) {</div><div>        await File(encryptedThumbnailPath).delete();</div><div>      }</div><div>      final encryptedThumbnailFile = File(encryptedThumbnailPath);</div><div>      await encryptedThumbnailFile</div><div>          .writeAsBytes(encryptedThumbnailData.encryptedData!);</div><div>      encThumbSize = await encryptedThumbnailFile.length();</div><div>      String? thumbnailMd5;</div><div>      if (flagService.enableUploadV2) {</div><div>        thumbnailMd5 = await computeMd5(encryptedThumbnailPath);</div><div>      }</div><div>      final bool useChecksumThumbnailUpload =</div><div>          flagService.enableUploadV2 &amp;&amp; thumbnailMd5?.isNotEmpty == true;</div><div></div><div>      // Calculate the number of parts for the file.</div><div>      final count = _multiPartUploader.calculatePartCount(encFileSize);</div><div></div><div>      late String fileObjectKey;</div><div>      late String thumbnailObjectKey;</div><div></div><div>      if (count &lt;= 1) {</div><div>        _logger.internalInfo(</div><div>          &quot;[UPLOAD-DEBUG] Non-multipart upload: Getting thumbnail upload URL...&quot;,</div><div>        );</div><div>        final thumbnailUploadURL = await _getUploadURL(</div><div>          contentLength: useChecksumThumbnailUpload ? encThumbSize : null,</div><div>          contentMd5: useChecksumThumbnailUpload ? thumbnailMd5 : null,</div><div>        );</div><div>        _logger.internalInfo(</div><div>          &quot;[UPLOAD-DEBUG] Thumbnail URL obtained, uploading thumbnail (size: ${formatBytes(encThumbSize)})...&quot;,</div><div>        );</div><div>        thumbnailObjectKey = await _putFile(</div><div>          thumbnailUploadURL,</div><div>          encryptedThumbnailFile,</div><div>          encThumbSize,</div><div>          contentMd5: thumbnailMd5,</div><div>        );</div><div>        _logger.internalInfo(</div><div>          &quot;[UPLOAD-DEBUG] Thumbnail uploaded successfully! Now getting file upload URL...&quot;,</div><div>        );</div><div>        final useChecksumUpload =</div><div>            flagService.enableUploadV2 &amp;&amp; fileMd5?.isNotEmpty == true;</div><div>        final fileUploadURL = await _getUploadURL(</div><div>          contentLength: useChecksumUpload ? encFileSize : null,</div><div>          contentMd5: useChecksumUpload ? fileMd5 : null,</div><div>        );</div><div>        _logger.internalInfo(</div><div>          &quot;[UPLOAD-DEBUG] File URL obtained, uploading actual file (size: ${formatBytes(encFileSize)})...&quot;,</div><div>        );</div><div>        fileObjectKey = await _putFile(</div><div>          fileUploadURL,</div><div>          encryptedFile,</div><div>          encFileSize,</div><div>          contentMd5: fileMd5,</div><div>        );</div><div>        _logger.internalInfo(</div><div>          &quot;[UPLOAD-DEBUG] Actual file uploaded successfully!&quot;,</div><div>        );</div><div>      } else {</div><div>        isMultipartUpload = true;</div><div>        _logger.info(</div><div>          &quot;Init multipartUpload $hasExistingMultiPart, isUpdate $isUpdatedFile&quot;,</div><div>        );</div><div>        if (hasExistingMultiPart) {</div><div>          fileObjectKey = await _multiPartUploader.putExistingMultipartFile(</div><div>            encryptedFile,</div><div>            lockKey,</div><div>            mediaUploadData.hashData!.fileHash!,</div><div>            collectionID,</div><div>            existingMultipartEncFileName,</div><div>          );</div><div>        } else {</div><div>          final multipartPartLength = fileAttributes.partSize ??</div><div>              _multiPartUploader.multipartPartSizeForUpload;</div><div>          final fileUploadURLs =</div><div>              await _multiPartUploader.getMultipartUploadURLs(</div><div>            count: count,</div><div>            contentLength: encFileSize,</div><div>            partLength: multipartPartLength,</div><div>            partMd5s: flagService.enableUploadV2 ? partMd5s : null,</div><div>          );</div><div>          final encFileName = encryptedFile.path.split(&#039;/&#039;).last;</div><div>          await _multiPartUploader.createTableEntry(</div><div>            lockKey,</div><div>            mediaUploadData.hashData!.fileHash!,</div><div>            collectionID,</div><div>            fileUploadURLs,</div><div>            encFileName,</div><div>            encFileSize,</div><div>            fileAttributes.key,</div><div>            fileAttributes.header,</div><div>            fileMd5: fileMd5,</div><div>            partMd5s: partMd5s,</div><div>          );</div><div>          fileObjectKey = await _multiPartUploader.putMultipartFile(</div><div>            fileUploadURLs,</div><div>            encryptedFile,</div><div>            encFileSize,</div><div>            fileMd5: fileMd5,</div><div>            partMd5s: partMd5s,</div><div>          );</div><div>        }</div><div>        // in case of multipart, upload the thumbnail towards the end to avoid</div><div>        // re-uploading the thumbnail in case of failure.</div><div>        // In regular upload, always upload the thumbnail first to keep existing behaviour</div><div>        //</div><div>        final thumbnailUploadURL = await _getUploadURL(</div><div>          contentLength: useChecksumThumbnailUpload ? encThumbSize : null,</div><div>          contentMd5: useChecksumThumbnailUpload ? thumbnailMd5 : null,</div><div>        );</div><div>        thumbnailObjectKey = await _putFile(</div><div>          thumbnailUploadURL,</div><div>          encryptedThumbnailFile,</div><div>          encThumbSize,</div><div>          contentMd5: thumbnailMd5,</div><div>        );</div><div>      }</div><div>      final ParsedExifDateTime? exifTime = await tryParseExifDateTime(</div><div>        null,</div><div>        mediaUploadData.exifData,</div><div>      );</div><div>      file.metadataVersion = EnteFile.kCurrentMetadataVersion;</div><div>      final metadata =</div><div>          await file.getMetadataForUpload(mediaUploadData, exifTime);</div><div></div><div>      final encryptedMetadataResult = await CryptoUtil.encryptChaCha(</div><div>        utf8.encode(jsonEncode(metadata)),</div><div>        fileAttributes.key,</div><div>      );</div><div>      final fileDecryptionHeader = CryptoUtil.bin2base64(fileAttributes.header);</div><div>      final thumbnailDecryptionHeader =</div><div>          CryptoUtil.bin2base64(encryptedThumbnailData.header!);</div><div>      final encryptedMetadata = CryptoUtil.bin2base64(</div><div>        encryptedMetadataResult.encryptedData!,</div><div>      );</div><div>      final metadataDecryptionHeader =</div><div>          CryptoUtil.bin2base64(encryptedMetadataResult.header!);</div><div>      if (SyncService.instance.shouldStopSync()) {</div><div>        throw SyncStopRequestedError();</div><div>      }</div><div>      final stillLocked =</div><div>          await _uploadLocks.isLocked(lockKey, _processType.toString());</div><div>      if (!stillLocked) {</div><div>        _logger.warning(&#039;file ${file.tag} report paused is missing&#039;);</div><div>        throw LockFreedError();</div><div>      }</div><div></div><div>      EnteFile remoteFile;</div><div>      if (isUpdatedFile) {</div><div>        // Verify that the encrypted file can be decrypted before uploading</div><div>        // For updates, we need to verify with the existing file key</div><div>        await CryptoUtil.decryptVerify(</div><div>          encryptedFilePath,</div><div>          fileDecryptionHeader,</div><div>          file.encryptedKey!,</div><div>          file.keyDecryptionNonce!,</div><div>          CollectionsService.instance.getCollectionKey(collectionID),</div><div>          chunkLimit: 1, // Verify at least first chunk</div><div>        );</div><div>        remoteFile = await _updateFile(</div><div>          file,</div><div>          fileObjectKey,</div><div>          fileDecryptionHeader,</div><div>          encFileSize,</div><div>          thumbnailObjectKey,</div><div>          thumbnailDecryptionHeader,</div><div>          encThumbSize,</div><div>          encryptedMetadata,</div><div>          metadataDecryptionHeader,</div><div>        );</div><div>        // Update across all collections</div><div>        await FilesDB.instance.updateUploadedFileAcrossCollections(remoteFile);</div><div>      } else {</div><div>        final encryptedFileKeyData = CryptoUtil.encryptSync(</div><div>          fileAttributes.key,</div><div>          CollectionsService.instance.getCollectionKey(collectionID),</div><div>        );</div><div>        final encryptedKey =</div><div>            CryptoUtil.bin2base64(encryptedFileKeyData.encryptedData!);</div><div>        final keyDecryptionNonce =</div><div>            CryptoUtil.bin2base64(encryptedFileKeyData.nonce!);</div><div>        final Map&lt;String, dynamic&gt; pubMetadata =</div><div>            _buildPublicMagicData(mediaUploadData, exifTime);</div><div>        MetadataRequest? pubMetadataRequest;</div><div>        if (pubMetadata.isNotEmpty) {</div><div>          pubMetadataRequest = await getPubMetadataRequest(</div><div>            file,</div><div>            pubMetadata,</div><div>            fileAttributes.key,</div><div>          );</div><div>        }</div><div>        await CryptoUtil.decryptVerify(</div><div>          encryptedFilePath,</div><div>          fileDecryptionHeader,</div><div>          encryptedKey,</div><div>          keyDecryptionNonce,</div><div>          CollectionsService.instance.getCollectionKey(collectionID),</div><div>          chunkLimit: 1, // Verify at least first chunk</div><div>        );</div><div></div><div>        remoteFile = await _uploadFile(</div><div>          file,</div><div>          collectionID,</div><div>          encryptedKey,</div><div>          keyDecryptionNonce,</div><div>          fileAttributes,</div><div>          fileObjectKey,</div><div>          fileDecryptionHeader,</div><div>          encFileSize,</div><div>          thumbnailObjectKey,</div><div>          thumbnailDecryptionHeader,</div><div>          encThumbSize,</div><div>          encryptedMetadata,</div><div>          metadataDecryptionHeader,</div><div>          pubMetadata: pubMetadataRequest,</div><div>        );</div><div>        if (mediaUploadData.isDeleted) {</div><div>          _logger.info(&quot;File found to be deleted&quot;);</div><div>          remoteFile.localID = null;</div><div>        }</div><div>        await FilesDB.instance.update(remoteFile);</div><div>      }</div><div>      await UploadLocksDB.instance.deleteMultipartTrack(lockKey);</div><div></div><div>      Bus.instance.fire(</div><div>        LocalPhotosUpdatedEvent(</div><div>          [remoteFile],</div><div>          source: &quot;uploadCompleted&quot;,</div><div>        ),</div><div>      );</div><div>      _logger.info(&quot;File upload complete for &quot; + remoteFile.toString());</div><div>      uploadCompleted = true;</div><div>      Bus.instance.fire(FileUploadedEvent(remoteFile));</div><div>      return remoteFile;</div><div>    } catch (e, s) {</div><div>      if (!(e is NoActiveSubscriptionError ||</div><div>          e is StorageLimitExceededError ||</div><div>          e is WiFiUnavailableError ||</div><div>          e is SilentlyCancelUploadsError ||</div><div>          e is InvalidFileError ||</div><div>          e is FileTooLargeForPlanError)) {</div><div>        _logger.severe(&quot;File upload failed for &quot; + file.toString(), e, s);</div><div>      }</div><div>      if (e is InvalidFileError) {</div><div>        _logger.severe(&quot;File upload ignored for &quot; + file.toString(), e);</div><div>        await _onInvalidFileError(file, e);</div><div>      }</div><div>      if ((e is StorageLimitExceededError ||</div><div>          e is FileTooLargeForPlanError ||</div><div>          e is NoActiveSubscriptionError)) {</div><div>        // file upload can not be retried in such cases without user intervention</div><div>        uploadHardFailure = true;</div><div>      }</div><div>      if ((isMultipartUpload || hasExistingMultiPart) &amp;&amp;</div><div>          isPutOrMultiPartError(e)) {</div><div>        await UploadLocksDB.instance.deleteMultipartTrack(lockKey);</div><div>      }</div><div>      rethrow;</div><div>    } finally {</div><div>      await _onUploadDone(</div><div>        mediaUploadData,</div><div>        uploadCompleted,</div><div>        uploadHardFailure,</div><div>        file,</div><div>        encryptedFilePath,</div><div>        encryptedThumbnailPath,</div><div>        lockKey: lockKey,</div><div>        isMultiPartUpload: isMultipartUpload,</div><div>      );</div><div>    }</div><div>  }</div><div></div><div>  Map&lt;String, dynamic&gt; _buildPublicMagicData(</div><div>    MediaUploadData mediaUploadData,</div><div>    ParsedExifDateTime? exifTime,</div><div>  ) {</div><div>    final Map&lt;String, dynamic&gt; pubMetadata = {};</div><div>    if ((mediaUploadData.height ?? 0) != 0 &amp;&amp;</div><div>        (mediaUploadData.width ?? 0) != 0) {</div><div>      pubMetadata[heightKey] = mediaUploadData.height;</div><div>      pubMetadata[widthKey] = mediaUploadData.width;</div><div>      pubMetadata[mediaTypeKey] = mediaUploadData.isPanorama == true ? 1 : 0;</div><div>    }</div><div>    if (mediaUploadData.motionPhotoStartIndex != null) {</div><div>      pubMetadata[motionVideoIndexKey] = mediaUploadData.motionPhotoStartIndex;</div><div>    }</div><div>    if (mediaUploadData.thumbnail == null) {</div><div>      pubMetadata[noThumbKey] = true;</div><div>    }</div><div>    if (exifTime != null) {</div><div>      if (exifTime.dateTime != null) {</div><div>        pubMetadata[dateTimeKey] = exifTime.dateTime;</div><div>      }</div><div>      if (exifTime.offsetTime != null) {</div><div>        pubMetadata[offsetTimeKey] = exifTime.offsetTime;</div><div>      }</div><div>    }</div><div>    return pubMetadata;</div><div>  }</div><div></div><div>  bool isPutOrMultiPartError(Object e) {</div><div>    if (e is MultiPartFileMissingError ||</div><div>        e is MultiPartError ||</div><div>        e is BadMD5DigestError) {</div><div>      return true;</div><div>    }</div><div>    if (e is DioException) {</div><div>      return e.requestOptions.path.contains(&quot;/files&quot;) ||</div><div>          e.requestOptions.path.contains(&quot;/files/update&quot;);</div><div>    }</div><div>    return false;</div><div>  }</div><div></div><div>  /*</div><div>  _mapToExistingUpload links the fileToUpload with the existing uploaded</div><div>  files. if the link is successful, it returns true otherwise false.</div><div>  When false, we should go ahead and re-upload or update the file.</div><div>  It performs following checks:</div><div>    a) Target file with same localID and destination collection exists. Delete the</div><div>     fileToUpload entry. If target file is sandbox file, then we skip localID match</div><div>     check.</div><div>    b) Uploaded file in any collection but with missing localID.</div><div>     Update the localID for uploadedFile and delete the fileToUpload entry</div><div>    c) A uploaded file exist with same localID but in a different collection.</div><div>    Add a symlink in the destination collection and update the fileToUpload.</div><div>    If target file is sandbox file, then we skip localID match</div><div>     check.</div><div>    d) File already exists but different localID. Re-upload</div><div>    In case the existing files already have local identifier, which is</div><div>    different from the {fileToUpload}, then most probably device has</div><div>    duplicate files.</div><div>  */</div><div>  Future&lt;Tuple2&lt;bool, EnteFile&gt;&gt; _mapToExistingUploadWithSameHash(</div><div>    MediaUploadData mediaUploadData,</div><div>    EnteFile fileToUpload,</div><div>    int toCollectionID,</div><div>  ) async {</div><div>    if (fileToUpload.uploadedFileID != null) {</div><div>      // ideally this should never happen, but because the code below this case</div><div>      // can do unexpected mapping, we are adding this additional check</div><div>      _logger.severe(</div><div>        &#039;Critical: file is already uploaded, skipped mapping&#039;,</div><div>      );</div><div>      return Tuple2(false, fileToUpload);</div><div>    }</div><div>    final bool isSandBoxFile = fileToUpload.isSharedMediaToAppSandbox;</div><div></div><div>    final List&lt;EnteFile&gt; existingUploadedFiles =</div><div>        await FilesDB.instance.getUploadedFilesWithHashes(</div><div>      mediaUploadData.hashData!,</div><div>      fileToUpload.fileType,</div><div>      Configuration.instance.getUserID()!,</div><div>    );</div><div>    if (existingUploadedFiles.isEmpty) {</div><div>      // continueUploading this file</div><div>      return Tuple2(false, fileToUpload);</div><div>    }</div><div></div><div>    // case a</div><div>    final EnteFile? sameLocalSameCollection =</div><div>        existingUploadedFiles.firstWhereOrNull(</div><div>      (e) =&gt;</div><div>          e.collectionID == toCollectionID &amp;&amp;</div><div>          (e.localID == fileToUpload.localID || isSandBoxFile),</div><div>    );</div><div>    if (sameLocalSameCollection != null) {</div><div>      _logger.info(</div><div>        &quot;sameLocalSameCollection: toUpload  ${fileToUpload.tag} &quot;</div><div>        &quot;existing: ${sameLocalSameCollection.tag} $isSandBoxFile&quot;,</div><div>      );</div><div>      // should delete the fileToUploadEntry</div><div>      if (fileToUpload.generatedID != null) {</div><div>        await FilesDB.instance.deleteByGeneratedID(fileToUpload.generatedID!);</div><div>      }</div><div></div><div>      Bus.instance.fire(</div><div>        LocalPhotosUpdatedEvent(</div><div>          [fileToUpload],</div><div>          type: EventType.deletedFromEverywhere,</div><div>          source: &quot;sameLocalSameCollection&quot;, //</div><div>        ),</div><div>      );</div><div>      return Tuple2(true, sameLocalSameCollection);</div><div>    }</div><div></div><div>    // case b</div><div>    final EnteFile? fileMissingLocal = existingUploadedFiles.firstWhereOrNull(</div><div>      (e) =&gt; e.localID == null,</div><div>    );</div><div>    if (fileMissingLocal != null) {</div><div>      // update the local id of the existing file and delete the fileToUpload</div><div>      // entry</div><div>      _logger.info(</div><div>        &quot;fileMissingLocal: \n toUpload  ${fileToUpload.tag} &quot;</div><div>        &quot;\n existing: ${fileMissingLocal.tag}&quot;,</div><div>      );</div><div>      fileMissingLocal.localID = fileToUpload.localID;</div><div>      // set localID for the given uploadedID across collections</div><div>      await FilesDB.instance.updateLocalIDForUploaded(</div><div>        fileMissingLocal.uploadedFileID!,</div><div>        fileToUpload.localID!,</div><div>      );</div><div>      // For files selected from device, during collaborative upload, we don&#039;t</div><div>      // insert entries in the FilesDB. So, we don&#039;t need to delete the entry</div><div>      if (fileToUpload.generatedID != null) {</div><div>        await FilesDB.instance.deleteByGeneratedID(fileToUpload.generatedID!);</div><div>      }</div><div>      Bus.instance.fire(</div><div>        LocalPhotosUpdatedEvent(</div><div>          [fileToUpload],</div><div>          source: &quot;fileMissingLocal&quot;,</div><div>          type: EventType.deletedFromEverywhere, //</div><div>        ),</div><div>      );</div><div>      return Tuple2(true, fileMissingLocal);</div><div>    }</div><div></div><div>    // case c</div><div>    final EnteFile? fileExistsButDifferentCollection =</div><div>        existingUploadedFiles.firstWhereOrNull(</div><div>      (e) =&gt;</div><div>          e.collectionID != toCollectionID &amp;&amp;</div><div>          (e.localID == fileToUpload.localID || isSandBoxFile),</div><div>    );</div><div>    if (fileExistsButDifferentCollection != null) {</div><div>      _logger.info(</div><div>        &quot;fileExistsButDifferentCollection: toUpload  ${fileToUpload.tag} &quot;</div><div>        &quot;existing: ${fileExistsButDifferentCollection.tag} $isSandBoxFile&quot;,</div><div>      );</div><div>      final linkedFile = await CollectionsService.instance</div><div>          .linkLocalFileToExistingUploadedFileInAnotherCollection(</div><div>        toCollectionID,</div><div>        localFileToUpload: fileToUpload,</div><div>        existingUploadedFile: fileExistsButDifferentCollection,</div><div>      );</div><div>      return Tuple2(true, linkedFile);</div><div>    }</div><div>    final Set&lt;String&gt; matchLocalIDs = existingUploadedFiles</div><div>        .where(</div><div>          (e) =&gt; e.localID != null,</div><div>        )</div><div>        .map((e) =&gt; e.localID!)</div><div>        .toSet();</div><div>    _logger.info(</div><div>      &quot;Found hashMatch but probably with diff localIDs &quot;</div><div>      &quot;$matchLocalIDs&quot;,</div><div>    );</div><div>    // case d</div><div>    return Tuple2(false, fileToUpload);</div><div>  }</div><div></div><div>  Future&lt;void&gt; _onUploadDone(</div><div>    MediaUploadData? mediaUploadData,</div><div>    bool uploadCompleted,</div><div>    bool uploadHardFailure,</div><div>    EnteFile file,</div><div>    String encryptedFilePath,</div><div>    String encryptedThumbnailPath, {</div><div>    required String lockKey,</div><div>    bool isMultiPartUpload = false,</div><div>  }) async {</div><div>    if (mediaUploadData != null &amp;&amp; mediaUploadData.sourceFile != null) {</div><div>      // delete the file from app&#039;s internal cache if it was copied to app</div><div>      // for upload. On iOS, only remove the file from photo_manager/app cache</div><div>      // when upload is either completed or there&#039;s a tempFailure</div><div>      // Shared Media should only be cleared when the upload</div><div>      // succeeds.</div><div>      if ((Platform.isIOS &amp;&amp; (uploadCompleted || uploadHardFailure)) ||</div><div>          (uploadCompleted &amp;&amp; file.isSharedMediaToAppSandbox)) {</div><div>        await mediaUploadData.sourceFile?.delete();</div><div>      }</div><div>    }</div><div>    if (File(encryptedFilePath).existsSync()) {</div><div>      if (isMultiPartUpload &amp;&amp; !uploadCompleted) {</div><div>        _logger.info(</div><div>          &quot;skip delete for multipart encrypted file $encryptedFilePath&quot;,</div><div>        );</div><div>      } else {</div><div>        await File(encryptedFilePath).delete();</div><div>      }</div><div>    }</div><div>    if (File(encryptedThumbnailPath).existsSync()) {</div><div>      await File(encryptedThumbnailPath).delete();</div><div>    }</div><div>    await _uploadLocks.releaseLock(lockKey, _processType.toString());</div><div>  }</div><div></div><div>  /*</div><div>  _checkIfWithinStorageLimit verifies if the file size for encryption and upload</div><div>   is within the storage limit. It throws StorageLimitExceededError if the limit</div><div>    is exceeded. This check is best effort and may not be completely accurate</div><div>    due to UserDetail cache. It prevents infinite loops when clients attempt to</div><div>    upload files that exceed the server&#039;s storage limit + buffer.</div><div>    Note: Local storageBuffer is 20MB, server storageBuffer is 50MB, and an</div><div>    additional 30MB is reserved for thumbnails and encryption overhead.</div><div>   */</div><div>  Future&lt;void&gt; _checkIfWithinStorageLimit(File fileToBeUploaded) async {</div><div>    try {</div><div>      final UserDetails? userDetails =</div><div>          UserService.instance.getCachedUserDetails();</div><div>      if (userDetails == null) {</div><div>        return;</div><div>      }</div><div>      // add k20MBStorageBuffer to the free storage</div><div>      final num freeStorage = userDetails.getFreeStorage() + k20MBStorageBuffer;</div><div>      final num fileSize = await fileToBeUploaded.length();</div><div>      if (fileSize &gt; freeStorage) {</div><div>        _logger.warning(&#039;Storage limit exceeded fileSize $fileSize and &#039;</div><div>            &#039;freeStorage $freeStorage&#039;);</div><div>        throw StorageLimitExceededError();</div><div>      }</div><div>      if (fileSize &gt; kMaxFileSize10Gib) {</div><div>        _logger.warning(&#039;File size exceeds 10GiB fileSize $fileSize&#039;);</div><div>        throw InvalidFileError(</div><div>          &#039;file size above 10GiB&#039;,</div><div>          InvalidReason.tooLargeFile,</div><div>        );</div><div>      }</div><div>    } catch (e) {</div><div>      if (e is StorageLimitExceededError || e is InvalidFileError) {</div><div>        rethrow;</div><div>      } else {</div><div>        _logger.severe(&#039;Error checking storage limit&#039;, e);</div><div>      }</div><div>    }</div><div>  }</div><div></div><div>  Future _onInvalidFileError(EnteFile file, InvalidFileError e) async {</div><div>    try {</div><div>      final bool canIgnoreFile = file.localID != null &amp;&amp;</div><div>          file.deviceFolder != null &amp;&amp;</div><div>          file.title != null &amp;&amp;</div><div>          !file.isSharedMediaToAppSandbox;</div><div>      // If the file is not uploaded yet and either it can not be ignored or the</div><div>      // err is related to live photo media, delete the local entry</div><div>      final bool deleteEntry =</div><div>          !file.isUploaded &amp;&amp; (!canIgnoreFile || e.reason.isLivePhotoErr);</div><div></div><div>      if (e.reason != InvalidReason.thumbnailMissing || !canIgnoreFile) {</div><div>        _logger.severe(</div><div>          &quot;Invalid file, localDelete: $deleteEntry, ignored: $canIgnoreFile&quot;,</div><div>          e,</div><div>        );</div><div>      }</div><div>      if (deleteEntry) {</div><div>        await FilesDB.instance.deleteLocalFile(file);</div><div>      }</div><div>      if (canIgnoreFile) {</div><div>        await LocalSyncService.instance.ignoreUpload(file, e);</div><div>      }</div><div>    } catch (e, s) {</div><div>      _logger.severe(&quot;Failed to handle invalid file error&quot;, e, s);</div><div>    }</div><div>  }</div><div></div><div>  Future&lt;EnteFile&gt; _uploadFile(</div><div>    EnteFile file,</div><div>    int collectionID,</div><div>    String encryptedKey,</div><div>    String keyDecryptionNonce,</div><div>    FileEncryptResult fileAttributes,</div><div>    String fileObjectKey,</div><div>    String fileDecryptionHeader,</div><div>    int fileSize,</div><div>    String thumbnailObjectKey,</div><div>    String thumbnailDecryptionHeader,</div><div>    int thumbnailSize,</div><div>    String encryptedMetadata,</div><div>    String metadataDecryptionHeader, {</div><div>    MetadataRequest? pubMetadata,</div><div>    int attempt = 1,</div><div>  }) async {</div><div>    final request = {</div><div>      &quot;collectionID&quot;: collectionID,</div><div>      &quot;encryptedKey&quot;: encryptedKey,</div><div>      &quot;keyDecryptionNonce&quot;: keyDecryptionNonce,</div><div>      &quot;file&quot;: {</div><div>        &quot;objectKey&quot;: fileObjectKey,</div><div>        &quot;decryptionHeader&quot;: fileDecryptionHeader,</div><div>        &quot;size&quot;: fileSize,</div><div>      },</div><div>      &quot;thumbnail&quot;: {</div><div>        &quot;objectKey&quot;: thumbnailObjectKey,</div><div>        &quot;decryptionHeader&quot;: thumbnailDecryptionHeader,</div><div>        &quot;size&quot;: thumbnailSize,</div><div>      },</div><div>      &quot;metadata&quot;: {</div><div>        &quot;encryptedData&quot;: encryptedMetadata,</div><div>        &quot;decryptionHeader&quot;: metadataDecryptionHeader,</div><div>      },</div><div>    };</div><div>    if (pubMetadata != null) {</div><div>      request[&quot;pubMagicMetadata&quot;] = pubMetadata;</div><div>    }</div><div>    try {</div><div>      final response = await _enteDio.post(&quot;/files&quot;, data: request);</div><div>      final data = response.data;</div><div>      file.uploadedFileID = data[&quot;id&quot;];</div><div>      file.collectionID = collectionID;</div><div>      file.updationTime = data[&quot;updationTime&quot;];</div><div>      file.ownerID = data[&quot;ownerID&quot;];</div><div>      file.encryptedKey = encryptedKey;</div><div>      file.keyDecryptionNonce = keyDecryptionNonce;</div><div>      file.fileDecryptionHeader = fileDecryptionHeader;</div><div>      file.thumbnailDecryptionHeader = thumbnailDecryptionHeader;</div><div>      file.metadataDecryptionHeader = metadataDecryptionHeader;</div><div>      return file;</div><div>    } on DioException catch (e) {</div><div>      final int statusCode = e.response?.statusCode ?? -1;</div><div>      if (statusCode == 413) {</div><div>        throw FileTooLargeForPlanError();</div><div>      } else if (statusCode == 426) {</div><div>        _onStorageLimitExceeded();</div><div>      } else if (attempt &lt; kMaximumUploadAttempts &amp;&amp; statusCode == -1) {</div><div>        // retry when DioException contains no response/status code</div><div>        _logger</div><div>            .info(&quot;Upload file (${file.tag}) failed, will retry in 3 seconds&quot;);</div><div>        await Future.delayed(const Duration(seconds: 3));</div><div>        return _uploadFile(</div><div>          file,</div><div>          collectionID,</div><div>          encryptedKey,</div><div>          keyDecryptionNonce,</div><div>          fileAttributes,</div><div>          fileObjectKey,</div><div>          fileDecryptionHeader,</div><div>          fileSize,</div><div>          thumbnailObjectKey,</div><div>          thumbnailDecryptionHeader,</div><div>          thumbnailSize,</div><div>          encryptedMetadata,</div><div>          metadataDecryptionHeader,</div><div>          attempt: attempt + 1,</div><div>          pubMetadata: pubMetadata,</div><div>        );</div><div>      } else {</div><div>        _logger.severe(&quot;Failed to upload file ${file.tag}&quot;, e);</div><div>      }</div><div>      rethrow;</div><div>    }</div><div>  }</div><div></div><div>  Future&lt;EnteFile&gt; _updateFile(</div><div>    EnteFile file,</div><div>    String fileObjectKey,</div><div>    String fileDecryptionHeader,</div><div>    int fileSize,</div><div>    String thumbnailObjectKey,</div><div>    String thumbnailDecryptionHeader,</div><div>    int thumbnailSize,</div><div>    String encryptedMetadata,</div><div>    String metadataDecryptionHeader, {</div><div>    int attempt = 1,</div><div>  }) async {</div><div>    final request = {</div><div>      &quot;id&quot;: file.uploadedFileID,</div><div>      &quot;file&quot;: {</div><div>        &quot;objectKey&quot;: fileObjectKey,</div><div>        &quot;decryptionHeader&quot;: fileDecryptionHeader,</div><div>        &quot;size&quot;: fileSize,</div><div>      },</div><div>      &quot;thumbnail&quot;: {</div><div>        &quot;objectKey&quot;: thumbnailObjectKey,</div><div>        &quot;decryptionHeader&quot;: thumbnailDecryptionHeader,</div><div>        &quot;size&quot;: thumbnailSize,</div><div>      },</div><div>      &quot;metadata&quot;: {</div><div>        &quot;encryptedData&quot;: encryptedMetadata,</div><div>        &quot;decryptionHeader&quot;: metadataDecryptionHeader,</div><div>      },</div><div>    };</div><div>    try {</div><div>      final response = await _enteDio.put(&quot;/files/update&quot;, data: request);</div><div>      final data = response.data;</div><div>      file.uploadedFileID = data[&quot;id&quot;];</div><div>      file.updationTime = data[&quot;updationTime&quot;];</div><div>      file.fileDecryptionHeader = fileDecryptionHeader;</div><div>      file.thumbnailDecryptionHeader = thumbnailDecryptionHeader;</div><div>      file.metadataDecryptionHeader = metadataDecryptionHeader;</div><div>      return file;</div><div>    } on DioException catch (e) {</div><div>      final int statusCode = e.response?.statusCode ?? -1;</div><div>      if (statusCode == 426) {</div><div>        _onStorageLimitExceeded();</div><div>      } else if (attempt &lt; kMaximumUploadAttempts &amp;&amp; statusCode == -1) {</div><div>        _logger</div><div>            .info(&quot;Update file (${file.tag}) failed, will retry in 3 seconds&quot;);</div><div>        await Future.delayed(const Duration(seconds: 3));</div><div>        return _updateFile(</div><div>          file,</div><div>          fileObjectKey,</div><div>          fileDecryptionHeader,</div><div>          fileSize,</div><div>          thumbnailObjectKey,</div><div>          thumbnailDecryptionHeader,</div><div>          thumbnailSize,</div><div>          encryptedMetadata,</div><div>          metadataDecryptionHeader,</div><div>          attempt: attempt + 1,</div><div>        );</div><div>      } else {</div><div>        _logger.severe(&quot;Failed to update file ${file.tag}&quot;, e);</div><div>      }</div><div>      rethrow;</div><div>    }</div><div>  }</div><div></div><div>  Future&lt;UploadURL&gt; _getUploadURL({</div><div>    int? contentLength,</div><div>    String? contentMd5,</div><div>  }) async {</div><div>    final bool useSingleEndpoint = flagService.enableUploadV2 &amp;&amp;</div><div>        contentLength != null &amp;&amp;</div><div>        contentMd5 != null &amp;&amp;</div><div>        contentMd5.isNotEmpty;</div><div></div><div>    final uploadURL = useSingleEndpoint</div><div>        ? await _requestChecksumProtectedUploadURL(</div><div>            contentLength: contentLength,</div><div>            contentMd5: contentMd5,</div><div>          )</div><div>        : await _getLegacyUploadURL();</div><div></div><div>    return _registerUploadURLUsage(uploadURL);</div><div>  }</div><div></div><div>  Future&lt;UploadURL&gt; _requestChecksumProtectedUploadURL({</div><div>    required int contentLength,</div><div>    required String contentMd5,</div><div>  }) async {</div><div>    _logger.internalInfo(</div><div>      &quot;[UPLOAD-DEBUG] Requesting single upload URL with checksum metadata (size: ${formatBytes(contentLength)})&quot;,</div><div>    );</div><div>    final response = await _enteDio.post(</div><div>      &quot;/files/upload-url&quot;,</div><div>      data: {</div><div>        &quot;contentLength&quot;: contentLength,</div><div>        &quot;contentMD5&quot;: contentMd5,</div><div>      },</div><div>    );</div><div>    return UploadURL.fromMap(</div><div>      (response.data as Map).cast&lt;String, dynamic&gt;(),</div><div>    );</div><div>  }</div><div></div><div>  Future&lt;UploadURL&gt; _getLegacyUploadURL() async {</div><div>    _logger.internalInfo(</div><div>      &quot;[UPLOAD-DEBUG] _getUploadURL() called. URL queue size: ${_uploadURLs.length}, Upload queue size: ${_queue.length}&quot;,</div><div>    );</div><div>    if (_uploadURLs.isEmpty) {</div><div>      _logger.internalInfo(</div><div>        &quot;[UPLOAD-DEBUG] URL queue is empty, fetching new upload URLs from server...&quot;,</div><div>      );</div><div>      // the queue is empty, fetch at least for one file to handle force uploads</div><div>      // that are not in the queue. This is to also avoid</div><div>      await fetchUploadURLs(math.max(_queue.length, 1));</div><div>      _logger.internalInfo(</div><div>        &quot;[UPLOAD-DEBUG] Successfully fetched upload URLs. New queue size: ${_uploadURLs.length}&quot;,</div><div>      );</div><div>    }</div><div>    try {</div><div>      final uploadURL = _uploadURLs.removeFirst();</div><div>      _logger.internalInfo(</div><div>        &quot;[UPLOAD-DEBUG] Returning upload URL. Remaining URLs in queue: ${_uploadURLs.length}&quot;,</div><div>      );</div><div>      return uploadURL;</div><div>    } catch (e) {</div><div>      if (e is StateError &amp;&amp; e.message == &#039;No element&#039; &amp;&amp; _queue.isEmpty) {</div><div>        _logger.warning(&quot;Oops, uploadUrls has no element now, fetching again&quot;);</div><div>        return _getLegacyUploadURL();</div><div>      } else {</div><div>        rethrow;</div><div>      }</div><div>    }</div><div>  }</div><div></div><div>  UploadURL _registerUploadURLUsage(UploadURL uploadURL) {</div><div>    // Atomic check-and-set to prevent race conditions in parallel uploads</div><div>    final now = DateTime.now();</div><div>    final existingTimestamp =</div><div>        _usedUploadURLs.putIfAbsent(uploadURL.url, () =&gt; now);</div><div></div><div>    if (existingTimestamp != now) {</div><div>      throw DuplicateUploadURLError(</div><div>        firstUsedAt: existingTimestamp,</div><div>        duplicateUsedAt: now,</div><div>      );</div><div>    }</div><div>    // Clean up old entries to prevent memory growth (only when &gt; 5000 entries)</div><div>    if (_usedUploadURLs.length &gt; 5000) {</div><div>      final oneHourAgo = now.subtract(const Duration(hours: 1));</div><div>      _usedUploadURLs.removeWhere((key, value) =&gt; value.isBefore(oneHourAgo));</div><div>      _logger.info(</div><div>        &quot;Cleaned up used upload URLs, remaining: ${_usedUploadURLs.length}&quot;,</div><div>      );</div><div>    }</div><div></div><div>    return uploadURL;</div><div>  }</div><div></div><div>  Future&lt;void&gt;? _uploadURLFetchInProgress;</div><div></div><div>  Future&lt;void&gt; fetchUploadURLs(int fileCount) async {</div><div>    _uploadURLFetchInProgress ??= Future&lt;void&gt;(() async {</div><div>      try {</div><div>        final requestCount = math.min(42, fileCount * 2);</div><div>        _logger.internalInfo(</div><div>          &quot;[UPLOAD-DEBUG] fetchUploadURLs() starting HTTP GET to /files/upload-urls with count=$requestCount&quot;,</div><div>        );</div><div>        final response = await _enteDio.get(</div><div>          &quot;/files/upload-urls&quot;,</div><div>          queryParameters: {</div><div>            &quot;count&quot;: requestCount, // m4gic number</div><div>          },</div><div>        );</div><div>        _logger.internalInfo(</div><div>          &quot;[UPLOAD-DEBUG] HTTP GET completed, parsing ${(response.data[&quot;urls&quot;] as List).length} URLs...&quot;,</div><div>        );</div><div>        final urls = (response.data[&quot;urls&quot;] as List)</div><div>            .map((e) =&gt; UploadURL.fromMap(e))</div><div>            .toList();</div><div>        _uploadURLs.addAll(urls);</div><div>        _logger.internalInfo(</div><div>          &quot;[UPLOAD-DEBUG] fetchUploadURLs() completed. Added ${urls.length} URLs to queue.&quot;,</div><div>        );</div><div>      } on DioException catch (e, s) {</div><div>        if (e.response != null) {</div><div>          if (e.response!.statusCode == 402) {</div><div>            final error = NoActiveSubscriptionError();</div><div>            clearQueue(error);</div><div>            throw error;</div><div>          } else if (e.response!.statusCode == 426) {</div><div>            final error = StorageLimitExceededError();</div><div>            clearQueue(error);</div><div>            throw error;</div><div>          } else {</div><div>            _logger.warning(&quot;Could not fetch upload URLs&quot;, e, s);</div><div>          }</div><div>        }</div><div>        rethrow;</div><div>      } finally {</div><div>        _uploadURLFetchInProgress = null;</div><div>      }</div><div>    });</div><div>    return _uploadURLFetchInProgress;</div><div>  }</div><div></div><div>  void _onStorageLimitExceeded() {</div><div>    clearQueue(StorageLimitExceededError());</div><div>    throw StorageLimitExceededError();</div><div>  }</div><div></div><div>  Future&lt;String&gt; _putFile(</div><div>    UploadURL uploadURL,</div><div>    File file,</div><div>    int fileSize, {</div><div>    String? contentMd5,</div><div>    int attempt = 1,</div><div>  }) async {</div><div>    final startTime = DateTime.now().millisecondsSinceEpoch;</div><div>    final fileName = basename(file.path);</div><div>    int bytesSent = 0;</div><div>    try {</div><div>      final Map&lt;String, dynamic&gt; headers = {</div><div>        Headers.contentLengthHeader: fileSize,</div><div>      };</div><div>      if (contentMd5 != null) {</div><div>        headers[&#039;Content-MD5&#039;] = contentMd5;</div><div>      }</div><div></div><div>      await _dio.put(</div><div>        uploadURL.url,</div><div>        data: file.openRead(),</div><div>        options: Options(</div><div>          headers: headers,</div><div>        ),</div><div>        onSendProgress: (sent, total) {</div><div>          bytesSent = sent;</div><div>        },</div><div>      );</div><div>      _logger.info(</div><div>        &quot;Uploaded object $fileName of size: ${formatBytes(fileSize)} at speed: ${(fileSize / (DateTime.now().millisecondsSinceEpoch - startTime)).toStringAsFixed(2)} KB/s&quot;,</div><div>      );</div><div></div><div>      return uploadURL.objectKey;</div><div>    } on DioException catch (e) {</div><div>      if (e.response?.statusCode == 400 &amp;&amp;</div><div>              e.response?.data.toString().contains(&#039;BadDigest&#039;) == true ||</div><div>          e.response?.data.toString().contains(&#039;InvalidDigest&#039;) == true) {</div><div>        final String recomputedMd5 = await computeMd5(file.path);</div><div>        throw BadMD5DigestError(</div><div>          &quot;Failed ${e.response?.data}, sent: $contentMd5, computed: $recomputedMd5&quot;,</div><div>        );</div><div>      } else if (e.message?.startsWith(&quot;HttpException: Content size&quot;) ??</div><div>          false) {</div><div>        rethrow;</div><div>      } else if (attempt &lt; kMaximumUploadAttempts) {</div><div>        _logger.info(</div><div>          &quot;Upload failed for $fileName after sending ${formatBytes(bytesSent)} of ${formatBytes(fileSize)}, retrying attempt ${attempt + 1}&quot;,</div><div>        );</div><div>        final newUploadURL = await _getUploadURL();</div><div>        return _putFile(</div><div>          newUploadURL,</div><div>          file,</div><div>          fileSize,</div><div>          contentMd5: contentMd5,</div><div>          attempt: attempt + 1,</div><div>        );</div><div>      } else {</div><div>        _logger.info(</div><div>          &quot;Failed to upload file ${basename(file.path)} after $attempt attempts&quot;,</div><div>          e,</div><div>        );</div><div>        rethrow;</div><div>      }</div><div>    }</div><div>  }</div><div></div><div>  // _pollBackgroundUploadStatus polls the background uploads to check if the</div><div>  // upload is completed or failed.</div><div>  Future&lt;void&gt; _pollBackgroundUploadStatus() async {</div><div>    final blockedUploads = _queue.entries</div><div>        .where((e) =&gt; e.value.status == UploadStatus.inBackground)</div><div>        .toList();</div><div>    for (final upload in blockedUploads) {</div><div>      final file = upload.value.file;</div><div>      final isStillLocked = await _uploadLocks.isLocked(</div><div>        file.localID!,</div><div>        ProcessType.background.toString(),</div><div>      );</div><div>      if (!isStillLocked) {</div><div>        final completer = _queue.remove(upload.key)?.completer;</div><div>        final dbFile =</div><div>            await FilesDB.instance.getFile(upload.value.file.generatedID!);</div><div>        if (dbFile?.uploadedFileID != null) {</div><div>          _logger.info(</div><div>            &quot;Background upload success detected ${upload.value.file.tag}&quot;,</div><div>          );</div><div>          completer?.complete(dbFile);</div><div>          _allBackups[upload.key] = _allBackups[upload.key]!</div><div>              .copyWith(status: BackupItemStatus.uploaded);</div><div>        } else {</div><div>          _logger.info(</div><div>            &quot;Background upload failure detected ${upload.value.file.tag}&quot;,</div><div>          );</div><div>          // The upload status is marked as in background, but the file is not locked</div><div>          // by the background process. Release any lock taken by the foreground process</div><div>          // and complete the completer with error.</div><div>          await _uploadLocks.releaseLock(</div><div>            file.localID!,</div><div>            ProcessType.foreground.toString(),</div><div>          );</div><div>          completer?.completeError(SilentlyCancelUploadsError());</div><div>          _allBackups[upload.key] = _allBackups[upload.key]!.copyWith(</div><div>            status: BackupItemStatus.retry,</div><div>            error: SilentlyCancelUploadsError(),</div><div>          );</div><div>        }</div><div></div><div>        Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>      }</div><div>    }</div><div>    Future.delayed(kBlockedUploadsPollFrequency, () async {</div><div>      await _pollBackgroundUploadStatus();</div><div>    });</div><div>  }</div><div>}</div><div></div><div>class FileUploadItem {</div><div>  final EnteFile file;</div><div>  final int collectionID;</div><div>  final Completer&lt;EnteFile&gt; completer;</div><div>  UploadStatus status;</div><div></div><div>  FileUploadItem(</div><div>    this.file,</div><div>    this.collectionID,</div><div>    this.completer, {</div><div>    this.status = UploadStatus.notStarted,</div><div>  });</div><div>}</div><div></div><div>enum UploadStatus { notStarted, inProgress, inBackground, completed }</div><div></div><div>enum ProcessType {</div><div>  background,</div><div>  foreground,</div><div>}</div><div></div></div></div></div><div class="assistant-text">Now let me look at how the device folder selection works and how it notifies the sync service:</div><div class="tool-execution" style="background-color: rgb(40, 50, 40)"><div class="tool-command">$ grep -r &quot;updateDeviceFolderSyncStatus\|BackupFoldersUpdatedEvent\|device.*folder\|shouldBackup&quot; /Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui --include=&quot;*.dart&quot; | head -30</div><div class="tool-output expandable" onclick="this.classList.toggle('expanded')"><div class="output-preview"><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/tabs/user_collections_tab.dart:import &quot;package:photos/ui/collections/device/device_folders_grid_view.dart&quot;;</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/tabs/user_collections_tab.dart:import &quot;package:photos/ui/collections/device/device_folders_vertical_grid_view.dart&quot;;</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/tabs/home_widget.dart:  late StreamSubscription&lt;BackupFoldersUpdatedEvent&gt; _backupFoldersUpdatedEvent;</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/tabs/home_widget.dart:        Bus.instance.on&lt;BackupFoldersUpdatedEvent&gt;().listen((event) async {</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/settings/backup/backup_folder_selection_page.dart:          if (file.shouldBackup) {</div><div class="expand-hint">... (25 more lines) - click to expand</div></div><div class="output-full"><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/tabs/user_collections_tab.dart:import &quot;package:photos/ui/collections/device/device_folders_grid_view.dart&quot;;</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/tabs/user_collections_tab.dart:import &quot;package:photos/ui/collections/device/device_folders_vertical_grid_view.dart&quot;;</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/tabs/home_widget.dart:  late StreamSubscription&lt;BackupFoldersUpdatedEvent&gt; _backupFoldersUpdatedEvent;</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/tabs/home_widget.dart:        Bus.instance.on&lt;BackupFoldersUpdatedEvent&gt;().listen((event) async {</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/settings/backup/backup_folder_selection_page.dart:          if (file.shouldBackup) {</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/settings/backup/backup_folder_selection_page.dart:      await RemoteSyncService.instance.updateDeviceFolderSyncStatus(syncStatus);</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/settings/backup/backup_settings_screen.dart:                                    .shouldBackupOverMobileData(),</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/settings/backup/backup_settings_screen.dart:                                        .shouldBackupOverMobileData(),</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/settings/backup/backup_settings_screen.dart:                                    Configuration.instance.shouldBackupVideos(),</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/settings/backup/backup_settings_screen.dart:                                  !Configuration.instance.shouldBackupVideos(),</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/home/home_gallery_widget.dart:        Bus.instance.on&lt;BackupFoldersUpdatedEvent&gt;(),</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/viewer/file_details/albums_item_widget.dart:    //Typing this as Future&lt;Set&lt;T&gt;&gt; as it would be easier to implement showing multiple device folders for a file in the future</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/viewer/gallery/device_folder_page.dart:      tagPrefix: &quot;device_folder:&quot; + deviceCollection.name,</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/viewer/gallery/device_folder_page.dart:  late ValueNotifier&lt;bool&gt; shouldBackup;</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/viewer/gallery/device_folder_page.dart:    shouldBackup = ValueNotifier(widget.deviceCollection.shouldBackup);</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/viewer/gallery/device_folder_page.dart:                  value: () =&gt; shouldBackup.value,</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/viewer/gallery/device_folder_page.dart:                      &quot;Toggling device folder sync status to &quot;</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/viewer/gallery/device_folder_page.dart:                      &quot;${!shouldBackup.value}&quot;,</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/viewer/gallery/device_folder_page.dart:                          .updateDeviceFolderSyncStatus(</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/viewer/gallery/device_folder_page.dart:                        {widget.deviceCollection.id: !shouldBackup.value},</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/viewer/gallery/device_folder_page.dart:                          shouldBackup.value = !shouldBackup.value;</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/viewer/gallery/device_folder_page.dart:                        &quot;Could not update device folder sync status&quot;,</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/viewer/gallery/device_folder_page.dart:                valueListenable: shouldBackup,</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/viewer/gallery/device_folder_page.dart:                      shouldBackup.value) {</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/actions/file/file_actions.dart:          // 2. We&#039;re in a local-only context (device folder - file disappears from this view)</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/collections/device/device_folders_grid_view.dart:import &quot;package:photos/ui/collections/device/device_folder_item.dart&quot;;</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/collections/device/device_folders_grid_view.dart:  StreamSubscription&lt;BackupFoldersUpdatedEvent&gt;? _backupFoldersUpdatedEvent;</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/collections/device/device_folders_grid_view.dart:        Bus.instance.on&lt;BackupFoldersUpdatedEvent&gt;().listen((event) {</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/collections/device/device_folder_item.dart:import &#039;package:photos/ui/viewer/gallery/device_folder_page.dart&#039;;</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/collections/device/device_folder_item.dart:    final isBackedUp = deviceCollection.shouldBackup;</div></div></div></div><div class="tool-execution" style="background-color: rgb(40, 50, 40)"><div class="tool-command">$ find /Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib -name &quot;*.dart&quot; | xargs grep -l &quot;BackupFoldersUpdatedEvent\|backup.*folder\|device.*folder&quot; | head -20</div><div class="tool-output expandable" onclick="this.classList.toggle('expanded')"><div class="output-preview"><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_et.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_ko.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_he.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_eu.dart</div><div class="expand-hint">... (15 more lines) - click to expand</div></div><div class="output-full"><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_et.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_ko.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_he.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_eu.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_gu.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_el.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_hi.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_ca.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_bg.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_af.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_ti.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_da.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_lv.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_fa.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_te.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_nn.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_th.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_sv.dart</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/generated/intl/app_localizations_hu.dart</div></div></div></div><div class="tool-execution" style="background-color: rgb(40, 50, 40)"><div class="tool-header"><span class="tool-name">read</span> <span class="tool-path">~/dev/enteio/ente/mobile/apps/photos/lib/ui/settings/backup/backup_folder_selection_page.dart</span></div><div class="tool-output expandable" onclick="this.classList.toggle('expanded')"><div class="output-preview"><div>import &#039;dart:ui&#039;;</div><div></div><div>import &#039;package:animated_list_plus/animated_list_plus.dart&#039;;</div><div>import &#039;package:animated_list_plus/transitions.dart&#039;;</div><div>import &#039;package:flutter/foundation.dart&#039;;</div><div>import &#039;package:flutter/material.dart&#039;;</div><div>import &#039;package:logging/logging.dart&#039;;</div><div>import &#039;package:photos/core/configuration.dart&#039;;</div><div>import &#039;package:photos/db/device_files_db.dart&#039;;</div><div>import &#039;package:photos/db/files_db.dart&#039;;</div><div class="expand-hint">... (439 more lines) - click to expand</div></div><div class="output-full"><div>import &#039;dart:ui&#039;;</div><div></div><div>import &#039;package:animated_list_plus/animated_list_plus.dart&#039;;</div><div>import &#039;package:animated_list_plus/transitions.dart&#039;;</div><div>import &#039;package:flutter/foundation.dart&#039;;</div><div>import &#039;package:flutter/material.dart&#039;;</div><div>import &#039;package:logging/logging.dart&#039;;</div><div>import &#039;package:photos/core/configuration.dart&#039;;</div><div>import &#039;package:photos/db/device_files_db.dart&#039;;</div><div>import &#039;package:photos/db/files_db.dart&#039;;</div><div>import &#039;package:photos/ente_theme_data.dart&#039;;</div><div>import &#039;package:photos/generated/l10n.dart&#039;;</div><div>import &#039;package:photos/models/device_collection.dart&#039;;</div><div>import &#039;package:photos/models/file/file.dart&#039;;</div><div>import &#039;package:photos/services/sync/remote_sync_service.dart&#039;;</div><div>import &quot;package:photos/theme/ente_theme.dart&quot;;</div><div>import &#039;package:photos/ui/common/loading_widget.dart&#039;;</div><div>import &#039;package:photos/ui/viewer/file/thumbnail_widget.dart&#039;;</div><div>import &#039;package:photos/utils/dialog_util.dart&#039;;</div><div></div><div>class BackupFolderSelectionPage extends StatefulWidget {</div><div>  final bool isFirstBackup;</div><div>  final bool isOnboarding;</div><div></div><div>  const BackupFolderSelectionPage({</div><div>    required this.isFirstBackup,</div><div>    this.isOnboarding = false,</div><div>    super.key,</div><div>  });</div><div></div><div>  @override</div><div>  State&lt;BackupFolderSelectionPage&gt; createState() =&gt;</div><div>      _BackupFolderSelectionPageState();</div><div>}</div><div></div><div>class _BackupFolderSelectionPageState extends State&lt;BackupFolderSelectionPage&gt; {</div><div>  final Logger _logger = Logger((_BackupFolderSelectionPageState).toString());</div><div>  final Set&lt;String&gt; _allDevicePathIDs = &lt;String&gt;{};</div><div>  final Set&lt;String&gt; _selectedDevicePathIDs = &lt;String&gt;{};</div><div>  List&lt;DeviceCollection&gt;? _deviceCollections;</div><div>  Map&lt;String, int&gt;? _pathIDToItemCount;</div><div></div><div>  @override</div><div>  void initState() {</div><div>    FilesDB.instance</div><div>        .getDeviceCollections(includeCoverThumbnail: true)</div><div>        .then((files) async {</div><div>      _pathIDToItemCount =</div><div>          await FilesDB.instance.getDevicePathIDToImportedFileCount();</div><div>      setState(() {</div><div>        _deviceCollections = files;</div><div>        _deviceCollections!.sort((first, second) {</div><div>          return first.name.toLowerCase().compareTo(second.name.toLowerCase());</div><div>        });</div><div>        for (final file in _deviceCollections!) {</div><div>          _allDevicePathIDs.add(file.id);</div><div>          if (file.shouldBackup) {</div><div>            _selectedDevicePathIDs.add(file.id);</div><div>          }</div><div>        }</div><div>        if (widget.isOnboarding) {</div><div>          _selectedDevicePathIDs.addAll(_allDevicePathIDs);</div><div>        }</div><div>        _selectedDevicePathIDs</div><div>            .removeWhere((folder) =&gt; !_allDevicePathIDs.contains(folder));</div><div>      });</div><div>    });</div><div>    super.initState();</div><div>  }</div><div></div><div>  @override</div><div>  Widget build(BuildContext context) {</div><div>    return Scaffold(</div><div>      appBar: widget.isOnboarding</div><div>          ? null</div><div>          : AppBar(</div><div>              elevation: 0,</div><div>              title: const Text(&quot;&quot;),</div><div>            ),</div><div>      body: Column(</div><div>        mainAxisAlignment: MainAxisAlignment.start,</div><div>        children: [</div><div>          const SizedBox(</div><div>            height: 0,</div><div>          ),</div><div>          SafeArea(</div><div>            child: Container(</div><div>              padding: const EdgeInsets.fromLTRB(24, 8, 24, 8),</div><div>              child: Text(</div><div>                AppLocalizations.of(context).selectFoldersForBackup,</div><div>                textAlign: TextAlign.left,</div><div>                style: TextStyle(</div><div>                  color: Theme.of(context).colorScheme.onSurface,</div><div>                  fontFamily: &#039;Inter-Bold&#039;,</div><div>                  fontSize: 32,</div><div>                  fontWeight: FontWeight.bold,</div><div>                ),</div><div>              ),</div><div>            ),</div><div>          ),</div><div>          Padding(</div><div>            padding: const EdgeInsets.only(left: 24, right: 48),</div><div>            child: Text(</div><div>              AppLocalizations.of(context)</div><div>                  .selectedFoldersWillBeEncryptedAndBackedUp,</div><div>              style:</div><div>                  Theme.of(context).textTheme.bodySmall!.copyWith(height: 1.3),</div><div>            ),</div><div>          ),</div><div>          const Padding(</div><div>            padding: EdgeInsets.all(10),</div><div>          ),</div><div>          _deviceCollections == null</div><div>              ? const SizedBox.shrink()</div><div>              : GestureDetector(</div><div>                  behavior: HitTestBehavior.translucent,</div><div>                  child: Padding(</div><div>                    padding: const EdgeInsets.fromLTRB(24, 6, 64, 12),</div><div>                    child: Align(</div><div>                      alignment: Alignment.centerLeft,</div><div>                      child: Text(</div><div>                        _selectedDevicePathIDs.length ==</div><div>                                _allDevicePathIDs.length</div><div>                            ? AppLocalizations.of(context).unselectAll</div><div>                            : AppLocalizations.of(context).selectAll,</div><div>                        textAlign: TextAlign.right,</div><div>                        style: const TextStyle(</div><div>                          decoration: TextDecoration.underline,</div><div>                          fontSize: 16,</div><div>                        ),</div><div>                      ),</div><div>                    ),</div><div>                  ),</div><div>                  onTap: () {</div><div>                    final hasSelectedAll = _selectedDevicePathIDs.length ==</div><div>                        _allDevicePathIDs.length;</div><div>                    // Flip selection</div><div>                    if (hasSelectedAll) {</div><div>                      _selectedDevicePathIDs.clear();</div><div>                    } else {</div><div>                      _selectedDevicePathIDs.addAll(_allDevicePathIDs);</div><div>                    }</div><div>                    _deviceCollections!.sort((first, second) {</div><div>                      return first.name</div><div>                          .toLowerCase()</div><div>                          .compareTo(second.name.toLowerCase());</div><div>                    });</div><div>                    setState(() {});</div><div>                  },</div><div>                ),</div><div>          Expanded(child: _getFolders()),</div><div>          SafeArea(</div><div>            child: Padding(</div><div>              padding: const EdgeInsets.only(bottom: 12),</div><div>              child: Column(</div><div>                children: [</div><div>                  Container(</div><div>                    width: double.infinity,</div><div>                    decoration: BoxDecoration(</div><div>                      boxShadow: [</div><div>                        BoxShadow(</div><div>                          color: getEnteColorScheme(context).backgroundBase,</div><div>                          blurRadius: 24,</div><div>                          offset: const Offset(0, -8),</div><div>                          spreadRadius: 4,</div><div>                        ),</div><div>                      ],</div><div>                    ),</div><div>                    padding: const EdgeInsets.only(left: 20, right: 20),</div><div>                    child: OutlinedButton(</div><div>                      onPressed:</div><div>                          widget.isOnboarding &amp;&amp; _selectedDevicePathIDs.isEmpty</div><div>                              ? null</div><div>                              : () async {</div><div>                                  await updateFolderSettings();</div><div>                                },</div><div>                      child: Text(</div><div>                        widget.isFirstBackup</div><div>                            ? AppLocalizations.of(context).startBackup</div><div>                            : AppLocalizations.of(context).backup,</div><div>                      ),</div><div>                    ),</div><div>                  ),</div><div>                  widget.isOnboarding</div><div>                      ? const SizedBox(height: 20)</div><div>                      : const SizedBox.shrink(),</div><div>                  widget.isOnboarding</div><div>                      ? GestureDetector(</div><div>                          key: const ValueKey(&quot;skipBackupButton&quot;),</div><div>                          behavior: HitTestBehavior.opaque,</div><div>                          onTap: () {</div><div>                            Navigator.of(context).pop();</div><div>                          },</div><div>                          child: Padding(</div><div>                            padding: const EdgeInsets.only(bottom: 8),</div><div>                            child: Text(</div><div>                              AppLocalizations.of(context).skip,</div><div>                              style: Theme.of(context)</div><div>                                  .textTheme</div><div>                                  .bodySmall!</div><div>                                  .copyWith(</div><div>                                    decoration: TextDecoration.underline,</div><div>                                  ),</div><div>                            ),</div><div>                          ),</div><div>                        )</div><div>                      : const SizedBox.shrink(),</div><div>                ],</div><div>              ),</div><div>            ),</div><div>          ),</div><div>        ],</div><div>      ),</div><div>    );</div><div>  }</div><div></div><div>  Future&lt;void&gt; updateFolderSettings() async {</div><div>    final dialog = createProgressDialog(</div><div>      context,</div><div>      AppLocalizations.of(context).updatingFolderSelection,</div><div>    );</div><div>    await dialog.show();</div><div>    try {</div><div>      final Map&lt;String, bool&gt; syncStatus = {};</div><div>      for (String pathID in _allDevicePathIDs) {</div><div>        syncStatus[pathID] = _selectedDevicePathIDs.contains(pathID);</div><div>      }</div><div>      await Configuration.instance.setHasSelectedAnyBackupFolder(</div><div>        _selectedDevicePathIDs.isNotEmpty,</div><div>      );</div><div>      await Configuration.instance.setSelectAllFoldersForBackup(</div><div>        _allDevicePathIDs.length == _selectedDevicePathIDs.length,</div><div>      );</div><div>      await RemoteSyncService.instance.updateDeviceFolderSyncStatus(syncStatus);</div><div>      await dialog.hide();</div><div>      Navigator.of(context).pop();</div><div>    } catch (e, s) {</div><div>      _logger.severe(&quot;Failed to updated backup folder&quot;, e, s);</div><div>      await dialog.hide();</div><div>      await showGenericErrorDialog(context: context, error: e);</div><div>    }</div><div>  }</div><div></div><div>  Widget _getFolders() {</div><div>    if (_deviceCollections == null) {</div><div>      return const EnteLoadingWidget();</div><div>    }</div><div>    _sortFiles();</div><div>    final scrollController = ScrollController();</div><div>    return Container(</div><div>      padding: const EdgeInsets.symmetric(horizontal: 20),</div><div>      child: Scrollbar(</div><div>        controller: scrollController,</div><div>        thumbVisibility: true,</div><div>        child: Padding(</div><div>          padding: const EdgeInsets.only(right: 4),</div><div>          child: ImplicitlyAnimatedReorderableList&lt;DeviceCollection&gt;(</div><div>            controller: scrollController,</div><div>            items: _deviceCollections!,</div><div>            areItemsTheSame: (oldItem, newItem) =&gt; oldItem.id == newItem.id,</div><div>            onReorderFinished: (item, from, to, newItems) {</div><div>              setState(() {</div><div>                _deviceCollections!</div><div>                  ..clear()</div><div>                  ..addAll(newItems);</div><div>              });</div><div>            },</div><div>            itemBuilder: (context, itemAnimation, file, index) {</div><div>              return Reorderable(</div><div>                key: ValueKey(file),</div><div>                builder: (context, dragAnimation, inDrag) {</div><div>                  final t = dragAnimation.value;</div><div>                  final elevation = lerpDouble(0, 8, t)!;</div><div>                  final themeColor = Theme.of(context).colorScheme.onSurface;</div><div>                  final color = Color.lerp(</div><div>                    themeColor,</div><div>                    themeColor.withValues(alpha: 0.8),</div><div>                    t,</div><div>                  );</div><div>                  return SizeFadeTransition(</div><div>                    sizeFraction: 0.7,</div><div>                    curve: Curves.easeInOut,</div><div>                    animation: itemAnimation,</div><div>                    child: Material(</div><div>                      color: color,</div><div>                      elevation: elevation,</div><div>                      type: MaterialType.transparency,</div><div>                      child: _getFileItem(file),</div><div>                    ),</div><div>                  );</div><div>                },</div><div>              );</div><div>            },</div><div>          ),</div><div>        ),</div><div>      ),</div><div>    );</div><div>  }</div><div></div><div>  Widget _getFileItem(DeviceCollection deviceCollection) {</div><div>    final isSelected = _selectedDevicePathIDs.contains(deviceCollection.id);</div><div>    final importedCount = _pathIDToItemCount != null</div><div>        ? _pathIDToItemCount![deviceCollection.id] ?? 0</div><div>        : -1;</div><div>    return Padding(</div><div>      padding: const EdgeInsets.only(bottom: 1, right: 1),</div><div>      child: Container(</div><div>        decoration: BoxDecoration(</div><div>          border: Border.all(</div><div>            color: Theme.of(context).colorScheme.boxUnSelectColor,</div><div>          ),</div><div>          borderRadius: const BorderRadius.all(</div><div>            Radius.circular(12),</div><div>          ),</div><div>          // color: isSelected</div><div>          //     ? Theme.of(context).colorScheme.boxSelectColor</div><div>          //     : Theme.of(context).colorScheme.boxUnSelectColor,</div><div>          gradient: isSelected</div><div>              ? const LinearGradient(</div><div>                  colors: [Color(0xFF00DD4D), Color(0xFF43BA6C)],</div><div>                ) //same for both themes</div><div>              : LinearGradient(</div><div>                  colors: [</div><div>                    Theme.of(context).colorScheme.boxUnSelectColor,</div><div>                    Theme.of(context).colorScheme.boxUnSelectColor,</div><div>                  ],</div><div>                ),</div><div>        ),</div><div>        padding: const EdgeInsets.fromLTRB(8, 4, 4, 4),</div><div>        child: InkWell(</div><div>          child: Row(</div><div>            mainAxisAlignment: MainAxisAlignment.spaceBetween,</div><div>            children: [</div><div>              Row(</div><div>                children: [</div><div>                  Checkbox(</div><div>                    checkColor: Colors.green,</div><div>                    activeColor: Colors.white,</div><div>                    value: isSelected,</div><div>                    onChanged: (value) {</div><div>                      if (value!) {</div><div>                        _selectedDevicePathIDs.add(deviceCollection.id);</div><div>                      } else {</div><div>                        _selectedDevicePathIDs.remove(deviceCollection.id);</div><div>                      }</div><div>                      setState(() {});</div><div>                    },</div><div>                  ),</div><div>                  Column(</div><div>                    crossAxisAlignment: CrossAxisAlignment.start,</div><div>                    children: [</div><div>                      Container(</div><div>                        constraints: const BoxConstraints(maxWidth: 180),</div><div>                        child: Text(</div><div>                          deviceCollection.name,</div><div>                          textAlign: TextAlign.left,</div><div>                          style: TextStyle(</div><div>                            fontFamily: &#039;Inter-Medium&#039;,</div><div>                            fontSize: 18,</div><div>                            fontWeight: FontWeight.w600,</div><div>                            color: isSelected</div><div>                                ? Colors.white</div><div>                                : Theme.of(context)</div><div>                                    .colorScheme</div><div>                                    .onSurface</div><div>                                    .withValues(alpha: 0.7),</div><div>                          ),</div><div>                          overflow: TextOverflow.ellipsis,</div><div>                          maxLines: 2,</div><div>                        ),</div><div>                      ),</div><div>                      const Padding(padding: EdgeInsets.only(top: 2)),</div><div>                      Text(</div><div>                        (kDebugMode ? &#039;inApp: $importedCount : device &#039; : &#039;&#039;) +</div><div>                            AppLocalizations.of(context)</div><div>                                .itemCount(count: deviceCollection.count),</div><div>                        textAlign: TextAlign.left,</div><div>                        style: TextStyle(</div><div>                          fontSize: 12,</div><div>                          color: isSelected</div><div>                              ? Colors.white</div><div>                              : Theme.of(context).colorScheme.onSurface,</div><div>                        ),</div><div>                      ),</div><div>                    ],</div><div>                  ),</div><div>                ],</div><div>              ),</div><div>              _getThumbnail(deviceCollection.thumbnail!, isSelected),</div><div>            ],</div><div>          ),</div><div>          onTap: () {</div><div>            final value = !_selectedDevicePathIDs.contains(deviceCollection.id);</div><div>            if (value) {</div><div>              _selectedDevicePathIDs.add(deviceCollection.id);</div><div>            } else {</div><div>              _selectedDevicePathIDs.remove(deviceCollection.id);</div><div>            }</div><div>            setState(() {});</div><div>          },</div><div>        ),</div><div>      ),</div><div>    );</div><div>  }</div><div></div><div>  void _sortFiles() {</div><div>    _deviceCollections!.sort((first, second) {</div><div>      if (_selectedDevicePathIDs.contains(first.id) &amp;&amp;</div><div>          _selectedDevicePathIDs.contains(second.id)) {</div><div>        return first.name.toLowerCase().compareTo(second.name.toLowerCase());</div><div>      } else if (_selectedDevicePathIDs.contains(first.id)) {</div><div>        return -1;</div><div>      } else if (_selectedDevicePathIDs.contains(second.id)) {</div><div>        return 1;</div><div>      }</div><div>      return first.name.toLowerCase().compareTo(second.name.toLowerCase());</div><div>    });</div><div>  }</div><div></div><div>  Widget _getThumbnail(EnteFile file, bool isSelected) {</div><div>    return ClipRRect(</div><div>      borderRadius: BorderRadius.circular(8),</div><div>      child: SizedBox(</div><div>        height: 88,</div><div>        width: 88,</div><div>        child: Stack(</div><div>          alignment: AlignmentDirectional.bottomEnd,</div><div>          children: [</div><div>            ThumbnailWidget(</div><div>              file,</div><div>              shouldShowSyncStatus: false,</div><div>              key: Key(&quot;backup_selection_widget&quot; + file.tag),</div><div>            ),</div><div>            Padding(</div><div>              padding: const EdgeInsets.all(9),</div><div>              child: isSelected</div><div>                  ? const Icon(</div><div>                      Icons.local_police,</div><div>                      color: Colors.white,</div><div>                    )</div><div>                  : null,</div><div>            ),</div><div>          ],</div><div>        ),</div><div>      ),</div><div>    );</div><div>  }</div><div>}</div><div></div></div></div></div><div class="assistant-text">Now let me look at the device folder page and the pending sync info screen:</div><div class="tool-execution" style="background-color: rgb(40, 50, 40)"><div class="tool-header"><span class="tool-name">read</span> <span class="tool-path">~/dev/enteio/ente/mobile/apps/photos/lib/ui/settings/pending_sync/pending_sync_info_screen.dart</span></div><div class="tool-output expandable" onclick="this.classList.toggle('expanded')"><div class="output-preview"><div>import &quot;package:flutter/material.dart&quot;;</div><div>import &quot;package:photos/core/configuration.dart&quot;;</div><div>import &quot;package:photos/generated/l10n.dart&quot;;</div><div>import &quot;package:photos/service_locator.dart&quot;;</div><div>import &quot;package:photos/ui/components/buttons/icon_button_widget.dart&quot;;</div><div>import &quot;package:photos/ui/components/menu_section_title.dart&quot;;</div><div>import &quot;package:photos/ui/components/title_bar_title_widget.dart&quot;;</div><div>import &quot;package:photos/ui/components/title_bar_widget.dart&quot;;</div><div>import &quot;package:photos/ui/settings/pending_sync/path_info_storage_viewer.dart&quot;;</div><div></div><div class="expand-hint">... (164 more lines) - click to expand</div></div><div class="output-full"><div>import &quot;package:flutter/material.dart&quot;;</div><div>import &quot;package:photos/core/configuration.dart&quot;;</div><div>import &quot;package:photos/generated/l10n.dart&quot;;</div><div>import &quot;package:photos/service_locator.dart&quot;;</div><div>import &quot;package:photos/ui/components/buttons/icon_button_widget.dart&quot;;</div><div>import &quot;package:photos/ui/components/menu_section_title.dart&quot;;</div><div>import &quot;package:photos/ui/components/title_bar_title_widget.dart&quot;;</div><div>import &quot;package:photos/ui/components/title_bar_widget.dart&quot;;</div><div>import &quot;package:photos/ui/settings/pending_sync/path_info_storage_viewer.dart&quot;;</div><div></div><div>// Preview Video related items -&gt; pv</div><div>// final String tempDir = Configuration.instance.getTempDirectory();</div><div>// final String prefix = &quot;${tempDir}_${enteFile.uploadedFileID}_${newID(&quot;pv&quot;)}&quot;;</div><div>//</div><div>// Recovery Key -&gt; ente-recovery-key.txt</div><div>// Configuration.instance.getTempDirectory() + &quot;ente-recovery-key.txt&quot;,</div><div>//</div><div>// Encrypted files (upload), decrypted files (download) -&gt; .encrypted &amp; .decrypted</div><div>//   final String tempDir = Configuration.instance.getTempDirectory();</div><div>//   final String encryptedFilePath = &quot;$tempDir${file.uploadedFileID}.encrypted&quot;;</div><div>//   final String decryptedFilePath = &quot;$tempDir${file.uploadedFileID}.decrypted&quot;;</div><div>//</div><div>// Live photo compressed version -&gt; .elp</div><div>// final livePhotoPath = tempPath + uniqueId + &quot;_${file.generatedID}.elp&quot;;</div><div>//</div><div>// Explicit uploads -&gt; _file.encrpyted &amp; _thumb.encrypted</div><div>// final encryptedFilePath = multipartEntryExists</div><div>//     ? &#039;$tempDirectory$existingMultipartEncFileName&#039;</div><div>//     : &#039;$tempDirectory$uploadTempFilePrefix${uniqueID}_file.encrypted&#039;;</div><div>// final encryptedThumbnailPath =</div><div>//     &#039;$tempDirectory$uploadTempFilePrefix${uniqueID}_thumb.encrypted&#039;;</div><div></div><div>class PendingSyncInfoScreen extends StatefulWidget {</div><div>  const PendingSyncInfoScreen({super.key});</div><div></div><div>  @override</div><div>  State&lt;PendingSyncInfoScreen&gt; createState() =&gt; _PendingSyncInfoScreenState();</div><div>}</div><div></div><div>class _PendingSyncInfoScreenState extends State&lt;PendingSyncInfoScreen&gt; {</div><div>  final List&lt;PathInfoStorageItem&gt; paths = [];</div><div>  late bool internalUser;</div><div>  final int _refreshCounterKey = 0;</div><div></div><div>  @override</div><div>  void initState() {</div><div>    super.initState();</div><div>    internalUser = flagService.internalUser;</div><div>    addPath();</div><div>  }</div><div></div><div>  void addPath() async {</div><div>    final String tempDownload = Configuration.instance.getTempDirectory();</div><div>    paths.addAll([</div><div>      PathInfoStorageItem.name(</div><div>        tempDownload,</div><div>        &quot;Encrypted Upload (File)&quot;,</div><div>        &quot;_file.encrypted&quot;,</div><div>        allowCacheClear: false,</div><div>      ),</div><div>      PathInfoStorageItem.name(</div><div>        tempDownload,</div><div>        &quot;Encrypted Upload (Thumb)&quot;,</div><div>        &quot;_thumb.encrypted&quot;,</div><div>        allowCacheClear: false,</div><div>      ),</div><div>      PathInfoStorageItem.name(</div><div>        tempDownload,</div><div>        &quot;Live photo&quot;,</div><div>        &quot;.elp&quot;,</div><div>        allowCacheClear: false,</div><div>      ),</div><div>      PathInfoStorageItem.name(</div><div>        tempDownload,</div><div>        &quot;Encrypted Data&quot;,</div><div>        &quot;.encrypted&quot;,</div><div>        allowCacheClear: false,</div><div>      ),</div><div>      PathInfoStorageItem.name(</div><div>        tempDownload,</div><div>        &quot;Decrypted Data&quot;,</div><div>        &quot;.decrypted&quot;,</div><div>        allowCacheClear: false,</div><div>      ),</div><div>      PathInfoStorageItem.name(</div><div>        tempDownload,</div><div>        &quot;Partial Download&quot;,</div><div>        &quot;_part&quot;,</div><div>        allowCacheClear: true,</div><div>      ),</div><div>      PathInfoStorageItem.name(</div><div>        tempDownload,</div><div>        &quot;Video Preview&quot;,</div><div>        &quot;pv&quot;,</div><div>        allowCacheClear: false,</div><div>      ),</div><div>    ]);</div><div>    if (mounted) {</div><div>      setState(() =&gt; {});</div><div>    }</div><div>  }</div><div></div><div>  @override</div><div>  Widget build(BuildContext context) {</div><div>    return Scaffold(</div><div>      body: CustomScrollView(</div><div>        primary: false,</div><div>        slivers: &lt;Widget&gt;[</div><div>          TitleBarWidget(</div><div>            flexibleSpaceTitle: const TitleBarTitleWidget(title: &quot;App Temp&quot;),</div><div>            actionIcons: [</div><div>              IconButtonWidget(</div><div>                icon: Icons.close_outlined,</div><div>                iconButtonType: IconButtonType.secondary,</div><div>                onTap: () {</div><div>                  Navigator.pop(context);</div><div>                  if (Navigator.canPop(context)) {</div><div>                    Navigator.pop(context);</div><div>                  }</div><div>                  if (Navigator.canPop(context)) {</div><div>                    Navigator.pop(context);</div><div>                  }</div><div>                },</div><div>              ),</div><div>            ],</div><div>          ),</div><div>          SliverList(</div><div>            delegate: SliverChildBuilderDelegate(</div><div>              (context, index) {</div><div>                return Padding(</div><div>                  padding: const EdgeInsets.symmetric(horizontal: 16),</div><div>                  child: Column(</div><div>                    mainAxisSize: MainAxisSize.min,</div><div>                    children: [</div><div>                      Column(</div><div>                        children: [</div><div>                          MenuSectionTitle(</div><div>                            title: AppLocalizations.of(context).cachedData,</div><div>                          ),</div><div>                          ListView.builder(</div><div>                            shrinkWrap: true,</div><div>                            padding: const EdgeInsets.all(0),</div><div>                            physics: const ScrollPhysics(),</div><div>                            // to disable GridView&#039;s scrolling</div><div>                            itemBuilder: (context, index) {</div><div>                              final path = paths[index];</div><div>                              return PathInfoStorageViewer(</div><div>                                path,</div><div>                                removeTopRadius: index &gt; 0,</div><div>                                removeBottomRadius: index &lt; paths.length - 1,</div><div>                                enableDoubleTapClear: internalUser,</div><div>                                key: ValueKey(&quot;$index-$_refreshCounterKey&quot;),</div><div>                              );</div><div>                            },</div><div>                            itemCount: paths.length,</div><div>                          ),</div><div>                          const SizedBox(</div><div>                            height: 24,</div><div>                          ),</div><div>                        ],</div><div>                      ),</div><div>                    ],</div><div>                  ),</div><div>                );</div><div>              },</div><div>              childCount: 1,</div><div>            ),</div><div>          ),</div><div>        ],</div><div>      ),</div><div>    );</div><div>  }</div><div>}</div><div></div></div></div></div><div class="tool-execution" style="background-color: rgb(40, 50, 40)"><div class="tool-command">$ grep -r &quot;getFilesToBeUploaded\|getFilesPendingForUpload\|getPendingUploadForCollection&quot; /Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib --include=&quot;*.dart&quot;</div><div class="tool-output expandable" onclick="this.classList.toggle('expanded')"><div class="output-preview"><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/db/files_db.dart:  Future&lt;List&lt;EnteFile&gt;&gt; getFilesPendingForUpload() async {</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/db/files_db.dart:  Future&lt;List&lt;EnteFile&gt;&gt; getPendingUploadForCollection(int collectionID) async {</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/services/sync/remote_sync_service.dart:      final filesToBeUploaded = await _getFilesToBeUploaded();</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/services/sync/remote_sync_service.dart:        final hasMoreFilesToBackup = (await _getFilesToBeUploaded()).isNotEmpty;</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/services/sync/remote_sync_service.dart:          await _db.getPendingUploadForCollection(collectionID);</div><div class="expand-hint">... (2 more lines) - click to expand</div></div><div class="output-full"><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/db/files_db.dart:  Future&lt;List&lt;EnteFile&gt;&gt; getFilesPendingForUpload() async {</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/db/files_db.dart:  Future&lt;List&lt;EnteFile&gt;&gt; getPendingUploadForCollection(int collectionID) async {</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/services/sync/remote_sync_service.dart:      final filesToBeUploaded = await _getFilesToBeUploaded();</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/services/sync/remote_sync_service.dart:        final hasMoreFilesToBackup = (await _getFilesToBeUploaded()).isNotEmpty;</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/services/sync/remote_sync_service.dart:          await _db.getPendingUploadForCollection(collectionID);</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/services/sync/remote_sync_service.dart:  Future&lt;List&lt;EnteFile&gt;&gt; _getFilesToBeUploaded() async {</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/services/sync/remote_sync_service.dart:    final List&lt;EnteFile&gt; originalFiles = await _db.getFilesPendingForUpload();</div></div></div></div><div class="assistant-text">Let me look at the database queries for pending uploads and device sync collections:</div><div class="tool-execution" style="background-color: rgb(40, 50, 40)"><div class="tool-command">$ grep -A 30 &quot;Future&lt;List&lt;EnteFile&gt;&gt; getFilesPendingForUpload&quot; /Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/db/files_db.dart</div><div class="tool-output expandable" onclick="this.classList.toggle('expanded')"><div class="output-preview"><div>Future&lt;List&lt;EnteFile&gt;&gt; getFilesPendingForUpload() async {</div><div>    final db = await instance.sqliteAsyncDB;</div><div>    final results = await db.getAll(</div><div>      &#039;SELECT * FROM $filesTable WHERE ($columnUploadedFileID IS NULL OR &#039;</div><div>      &#039;$columnUploadedFileID IS -1) AND $columnCollectionID IS NOT NULL AND &#039;</div><div class="expand-hint">... (25 more lines) - click to expand</div></div><div class="output-full"><div>Future&lt;List&lt;EnteFile&gt;&gt; getFilesPendingForUpload() async {</div><div>    final db = await instance.sqliteAsyncDB;</div><div>    final results = await db.getAll(</div><div>      &#039;SELECT * FROM $filesTable WHERE ($columnUploadedFileID IS NULL OR &#039;</div><div>      &#039;$columnUploadedFileID IS -1) AND $columnCollectionID IS NOT NULL AND &#039;</div><div>      &#039;$columnCollectionID IS NOT -1 AND $columnLocalID IS NOT NULL AND &#039;</div><div>      &#039;$columnLocalID IS NOT -1 GROUP BY $columnLocalID &#039;</div><div>      &#039;ORDER BY $columnCreationTime DESC&#039;,</div><div>    );</div><div>    final files = convertToFiles(results);</div><div>    // future-safe filter just to ensure that the query doesn&#039;t end up  returning files</div><div>    // which should not be backed up</div><div>    files.removeWhere(</div><div>      (e) =&gt;</div><div>          e.collectionID == null ||</div><div>          e.localID == null ||</div><div>          e.uploadedFileID != null,</div><div>    );</div><div>    return files;</div><div>  }</div><div></div><div>  Future&lt;List&lt;EnteFile&gt;&gt; getUnUploadedLocalFiles() async {</div><div>    final db = await instance.sqliteAsyncDB;</div><div>    final results = await db.getAll(</div><div>      &#039;SELECT * FROM $filesTable WHERE ($columnUploadedFileID IS NULL OR &#039;</div><div>      &#039;$columnUploadedFileID IS -1) AND $columnLocalID IS NOT NULL &#039;</div><div>      &#039;GROUP BY $columnLocalID ORDER BY $columnCreationTime DESC&#039;,</div><div>    );</div><div>    return convertToFiles(results);</div><div>  }</div></div></div></div><div class="tool-execution" style="background-color: rgb(60, 40, 40)"><div class="tool-command">$ grep -A 30 &quot;getDeviceSyncCollectionIDs\|removeFilesQueuedForUpload&quot; /Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/db/files_db.dart</div><div class="tool-output"><div>Command exited with code 1</div></div></div><div class="tool-execution" style="background-color: rgb(40, 50, 40)"><div class="tool-command">$ grep -n &quot;getDeviceSyncCollectionIDs\|removeFilesQueuedForUpload\|setCollectionIDForUnMappedLocalFiles\|removeQueuedLocalFiles&quot; /Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/db/files_db.dart</div><div class="tool-output"><div>985:  Future&lt;int&gt; removeQueuedLocalFiles(Set&lt;String&gt; localIDs, int ownerID) async {</div><div>1070:  Future&lt;void&gt; setCollectionIDForUnMappedLocalFiles(</div></div></div><div class="tool-execution" style="background-color: rgb(40, 50, 40)"><div class="tool-command">$ grep -n &quot;getDeviceSyncCollectionIDs&quot; /Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib --include=&quot;*.dart&quot; -r</div><div class="tool-output"><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/db/device_files_db.dart:264:  // getDeviceSyncCollectionIDs returns the collectionIDs for the</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/db/device_files_db.dart:266:  Future&lt;Set&lt;int&gt;&gt; getDeviceSyncCollectionIDs() async {</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/services/sync/remote_sync_service.dart:457:        await _db.getDeviceSyncCollectionIDs();</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/services/sync/remote_sync_service.dart:460:        await _db.getDeviceSyncCollectionIDs();</div></div></div><div class="tool-execution" style="background-color: rgb(40, 50, 40)"><div class="tool-command">$ grep -A 30 &quot;Future&lt;int&gt; removeQueuedLocalFiles&quot; /Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/db/files_db.dart</div><div class="tool-output expandable" onclick="this.classList.toggle('expanded')"><div class="output-preview"><div>Future&lt;int&gt; removeQueuedLocalFiles(Set&lt;String&gt; localIDs, int ownerID) async {</div><div>    if (localIDs.isEmpty) {</div><div>      _logger.finest(&quot;No local IDs provided for removal&quot;);</div><div>      return 0;</div><div>    }</div><div class="expand-hint">... (25 more lines) - click to expand</div></div><div class="output-full"><div>Future&lt;int&gt; removeQueuedLocalFiles(Set&lt;String&gt; localIDs, int ownerID) async {</div><div>    if (localIDs.isEmpty) {</div><div>      _logger.finest(&quot;No local IDs provided for removal&quot;);</div><div>      return 0;</div><div>    }</div><div></div><div>    final db = await instance.sqliteAsyncDB;</div><div>    const batchSize = 10000;</div><div>    int totalRemoved = 0;</div><div>    final localIDsList = localIDs.toList();</div><div></div><div>    for (int i = 0; i &lt; localIDsList.length; i += batchSize) {</div><div>      final endIndex = (i + batchSize &gt; localIDsList.length)</div><div>          ? localIDsList.length</div><div>          : i + batchSize;</div><div>      final batch = localIDsList.sublist(i, endIndex);</div><div>      final placeholders = List.filled(batch.length, &#039;?&#039;).join(&#039;,&#039;);</div><div></div><div>      // Find localIDs that already have uploaded entries</div><div>      final result = await db.execute(</div><div>        &#039;&#039;&#039;</div><div>      SELECT DISTINCT $columnLocalID</div><div>      FROM $filesTable</div><div>      WHERE </div><div>      $columnOwnerID = $ownerID</div><div>      AND $columnLocalID IN ($placeholders)</div><div>      AND ($columnUploadedFileID IS NOT NULL AND $columnUploadedFileID != -1)</div><div>    &#039;&#039;&#039;,</div><div>        batch,</div><div>      );</div></div></div></div><div class="tool-execution" style="background-color: rgb(40, 50, 40)"><div class="tool-header"><span class="tool-name">read</span> <span class="tool-path">~/dev/enteio/ente/mobile/apps/photos/lib/db/device_files_db.dart</span></div><div class="tool-output expandable" onclick="this.classList.toggle('expanded')"><div class="output-preview"><div>      rethrow;</div><div>    }</div><div>  }</div><div></div><div>  // getDeviceSyncCollectionIDs returns the collectionIDs for the</div><div>  // deviceCollections which are marked for auto-backup</div><div>  Future&lt;Set&lt;int&gt;&gt; getDeviceSyncCollectionIDs() async {</div><div>    final db = await sqliteAsyncDB;</div><div>    final rows = await db.getAll(</div><div>      &#039;&#039;&#039;</div><div class="expand-hint">... (52 more lines) - click to expand</div></div><div class="output-full"><div>      rethrow;</div><div>    }</div><div>  }</div><div></div><div>  // getDeviceSyncCollectionIDs returns the collectionIDs for the</div><div>  // deviceCollections which are marked for auto-backup</div><div>  Future&lt;Set&lt;int&gt;&gt; getDeviceSyncCollectionIDs() async {</div><div>    final db = await sqliteAsyncDB;</div><div>    final rows = await db.getAll(</div><div>      &#039;&#039;&#039;</div><div>      SELECT collection_id FROM device_collections where should_backup =</div><div>      $_sqlBoolTrue</div><div>      and collection_id != -1;</div><div>      &#039;&#039;&#039;,</div><div>    );</div><div>    final Set&lt;int&gt; result = &lt;int&gt;{};</div><div>    for (final row in rows) {</div><div>      result.add(row[&#039;collection_id&#039;] as int);</div><div>    }</div><div>    return result;</div><div>  }</div><div></div><div>  Future&lt;void&gt; updateDevicePathSyncStatus(</div><div>    Map&lt;String, bool&gt; syncStatus,</div><div>  ) async {</div><div>    final db = await sqliteAsyncDB;</div><div>    int batchCounter = 0;</div><div>    final parameterSets = &lt;List&lt;Object?&gt;&gt;[];</div><div>    for (MapEntry e in syncStatus.entries) {</div><div>      final String pathID = e.key;</div><div>      parameterSets.add([e.value ? _sqlBoolTrue : _sqlBoolFalse, pathID]);</div><div>      batchCounter++;</div><div></div><div>      if (batchCounter == 400) {</div><div>        await db.executeBatch(</div><div>          &#039;&#039;&#039;</div><div>          UPDATE device_collections SET should_backup = ? WHERE id = ?;</div><div>        &#039;&#039;&#039;,</div><div>          parameterSets,</div><div>        );</div><div>        parameterSets.clear();</div><div>        batchCounter = 0;</div><div>      }</div><div>    }</div><div></div><div>    await db.executeBatch(</div><div>      &#039;&#039;&#039;</div><div>          UPDATE device_collections SET should_backup = ? WHERE id = ?;</div><div>        &#039;&#039;&#039;,</div><div>      parameterSets,</div><div>    );</div><div>  }</div><div></div><div>  Future&lt;void&gt; updateDeviceCollection(</div><div>    String pathID,</div><div>    int collectionID,</div><div>  ) async {</div><div>    final db = await sqliteAsyncDB;</div><div>    await db.execute(</div><div>      &#039;&#039;&#039;</div><div></div><div>... (174 more lines not shown. Use offset=320 to continue reading)</div></div></div></div><div class="assistant-text">Now let me look at the events that are fired and how they&#039;re handled:</div><div class="tool-execution" style="background-color: rgb(40, 50, 40)"><div class="tool-header"><span class="tool-name">read</span> <span class="tool-path">~/dev/enteio/ente/mobile/apps/photos/lib/events/backup_folders_updated_event.dart</span></div><div class="tool-output"><div>import &#039;package:photos/events/event.dart&#039;;</div><div></div><div>class BackupFoldersUpdatedEvent extends Event {}</div><div></div></div></div><div class="tool-execution" style="background-color: rgb(40, 50, 40)"><div class="tool-command">$ grep -r &quot;BackupFoldersUpdatedEvent&quot; /Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib --include=&quot;*.dart&quot; | grep -v &quot;generated&quot; | head -20</div><div class="tool-output expandable" onclick="this.classList.toggle('expanded')"><div class="output-preview"><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/tabs/home_widget.dart:  late StreamSubscription&lt;BackupFoldersUpdatedEvent&gt; _backupFoldersUpdatedEvent;</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/tabs/home_widget.dart:        Bus.instance.on&lt;BackupFoldersUpdatedEvent&gt;().listen((event) async {</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/home/home_gallery_widget.dart:        Bus.instance.on&lt;BackupFoldersUpdatedEvent&gt;(),</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/collections/device/device_folders_grid_view.dart:  StreamSubscription&lt;BackupFoldersUpdatedEvent&gt;? _backupFoldersUpdatedEvent;</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/collections/device/device_folders_grid_view.dart:        Bus.instance.on&lt;BackupFoldersUpdatedEvent&gt;().listen((event) {</div><div class="expand-hint">... (5 more lines) - click to expand</div></div><div class="output-full"><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/tabs/home_widget.dart:  late StreamSubscription&lt;BackupFoldersUpdatedEvent&gt; _backupFoldersUpdatedEvent;</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/tabs/home_widget.dart:        Bus.instance.on&lt;BackupFoldersUpdatedEvent&gt;().listen((event) async {</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/home/home_gallery_widget.dart:        Bus.instance.on&lt;BackupFoldersUpdatedEvent&gt;(),</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/collections/device/device_folders_grid_view.dart:  StreamSubscription&lt;BackupFoldersUpdatedEvent&gt;? _backupFoldersUpdatedEvent;</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/collections/device/device_folders_grid_view.dart:        Bus.instance.on&lt;BackupFoldersUpdatedEvent&gt;().listen((event) {</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/collections/device/device_folders_vertical_grid_view.dart:  StreamSubscription&lt;BackupFoldersUpdatedEvent&gt;? _backupFoldersUpdatedEvent;</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/collections/device/device_folders_vertical_grid_view.dart:        Bus.instance.on&lt;BackupFoldersUpdatedEvent&gt;().listen((event) {</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/events/backup_folders_updated_event.dart:class BackupFoldersUpdatedEvent extends Event {}</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/services/sync/remote_sync_service.dart:    Bus.instance.fire(BackupFoldersUpdatedEvent());</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/services/sync/local_sync_service.dart:      Bus.instance.fire(BackupFoldersUpdatedEvent());</div></div></div></div><div class="assistant-text">Now let me look at how `onDeviceCollectionSet` is used and the flow:</div><div class="tool-execution" style="background-color: rgb(40, 50, 40)"><div class="tool-command">$ grep -B 5 -A 20 &quot;void onDeviceCollectionSet&quot; /Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/services/sync/sync_service.dart</div><div class="tool-output expandable" onclick="this.classList.toggle('expanded')"><div class="output-preview"><div>Future&lt;void&gt; onPermissionGranted() async {</div><div>    _doSync().ignore();</div><div>  }</div><div></div><div>  void onDeviceCollectionSet(Set&lt;int&gt; collectionIDs) {</div><div class="expand-hint">... (20 more lines) - click to expand</div></div><div class="output-full"><div>Future&lt;void&gt; onPermissionGranted() async {</div><div>    _doSync().ignore();</div><div>  }</div><div></div><div>  void onDeviceCollectionSet(Set&lt;int&gt; collectionIDs) {</div><div>    _uploader.removeFromQueueWhere(</div><div>      (file) {</div><div>        return !collectionIDs.contains(file.collectionID);</div><div>      },</div><div>      UserCancelledUploadError(),</div><div>    );</div><div>  }</div><div></div><div>  void onVideoBackupPaused() {</div><div>    _uploader.removeFromQueueWhere(</div><div>      (file) {</div><div>        return file.fileType == FileType.video;</div><div>      },</div><div>      UserCancelledUploadError(),</div><div>    );</div><div>  }</div><div></div><div>  Future&lt;void&gt; _doSync() async {</div><div>    _logger.info(&quot;[SYNC] Starting local sync&quot;);</div><div>    await _localSyncService.sync();</div></div></div></div><div class="tool-execution" style="background-color: rgb(40, 50, 40)"><div class="tool-command">$ grep -B 5 -A 50 &quot;updateDeviceFolderSyncStatus&quot; /Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/services/sync/remote_sync_service.dart</div><div class="tool-output expandable" onclick="this.classList.toggle('expanded')"><div class="output-preview"><div>Bus.instance.fire(ForceReloadHomeGalleryEvent(&quot;newFilesDisplay&quot;));</div><div>    }</div><div>    _hasCleanupStaleEntry = true;</div><div>  }</div><div></div><div class="expand-hint">... (51 more lines) - click to expand</div></div><div class="output-full"><div>Bus.instance.fire(ForceReloadHomeGalleryEvent(&quot;newFilesDisplay&quot;));</div><div>    }</div><div>    _hasCleanupStaleEntry = true;</div><div>  }</div><div></div><div>  Future&lt;void&gt; updateDeviceFolderSyncStatus(</div><div>    Map&lt;String, bool&gt; syncStatusUpdate,</div><div>  ) async {</div><div>    final Set&lt;int&gt; oldCollectionIDsForAutoSync =</div><div>        await _db.getDeviceSyncCollectionIDs();</div><div>    await _db.updateDevicePathSyncStatus(syncStatusUpdate);</div><div>    final Set&lt;int&gt; newCollectionIDsForAutoSync =</div><div>        await _db.getDeviceSyncCollectionIDs();</div><div>    SyncService.instance.onDeviceCollectionSet(newCollectionIDsForAutoSync);</div><div>    // remove all collectionIDs which are still marked for backup</div><div>    oldCollectionIDsForAutoSync.removeAll(newCollectionIDsForAutoSync);</div><div>    await removeFilesQueuedForUpload(oldCollectionIDsForAutoSync.toList());</div><div>    if (syncStatusUpdate.values.any((syncStatus) =&gt; syncStatus == false)) {</div><div>      Configuration.instance.setSelectAllFoldersForBackup(false).ignore();</div><div>    }</div><div>    Bus.instance.fire(</div><div>      LocalPhotosUpdatedEvent(&lt;EnteFile&gt;[], source: &quot;deviceFolderSync&quot;),</div><div>    );</div><div>    Bus.instance.fire(BackupFoldersUpdatedEvent());</div><div>  }</div><div></div><div>  Future&lt;void&gt; removeFilesQueuedForUpload(List&lt;int&gt; collectionIDs) async {</div><div>    /*</div><div>      For each collection, perform following action</div><div>      1) Get List of all files not uploaded yet</div><div>      2) Delete files who localIDs is also present in other collections.</div><div>      3) For Remaining files, set the collectionID as -1</div><div>     */</div><div>    _logger.info(&quot;Removing files for collections $collectionIDs&quot;);</div><div>    for (int collectionID in collectionIDs) {</div><div>      final List&lt;EnteFile&gt; pendingUploads =</div><div>          await _db.getPendingUploadForCollection(collectionID);</div><div>      if (pendingUploads.isEmpty) {</div><div>        continue;</div><div>      } else {</div><div>        _logger.info(</div><div>          &quot;RemovingFiles $collectionIDs: pendingUploads &quot;</div><div>          &quot;${pendingUploads.length}&quot;,</div><div>        );</div><div>      }</div><div>      final Set&lt;String&gt; localIDsInOtherFileEntries =</div><div>          await _db.getLocalIDsPresentInEntries(</div><div>        pendingUploads,</div><div>        collectionID,</div><div>      );</div><div>      _logger.info(</div><div>        &quot;RemovingFiles $collectionIDs: filesInOtherCollection &quot;</div><div>        &quot;${localIDsInOtherFileEntries.length}&quot;,</div><div>      );</div><div>      final List&lt;EnteFile&gt; entriesToUpdate = [];</div><div>      final List&lt;int&gt; entriesToDelete = [];</div></div></div></div><div class="assistant-text">Now I have a complete picture of the flow. Let me also check if there are any currently running uploads being tracked:</div><div class="tool-execution" style="background-color: rgb(40, 50, 40)"><div class="tool-command">$ grep -n &quot;BackupItem\|BackupUpdatedEvent\|_allBackups&quot; /Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/utils/file_uploader.dart | head -30</div><div class="tool-output expandable" onclick="this.classList.toggle('expanded')"><div class="output-preview"><div>68:  final LinkedHashMap&lt;String, BackupItem&gt; _allBackups =</div><div>69:      LinkedHashMap&lt;String, BackupItem&gt;();</div><div>78:  LinkedHashMap&lt;String, BackupItem&gt; get allBackups =&gt; _allBackups;</div><div>193:      _allBackups[localID] = BackupItem(</div><div>194:        status: BackupItemStatus.inQueue,</div><div class="expand-hint">... (25 more lines) - click to expand</div></div><div class="output-full"><div>68:  final LinkedHashMap&lt;String, BackupItem&gt; _allBackups =</div><div>69:      LinkedHashMap&lt;String, BackupItem&gt;();</div><div>78:  LinkedHashMap&lt;String, BackupItem&gt; get allBackups =&gt; _allBackups;</div><div>193:      _allBackups[localID] = BackupItem(</div><div>194:        status: BackupItemStatus.inQueue,</div><div>199:      Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>260:      _allBackups[id] = _allBackups[id]!.copyWith(</div><div>261:        status: BackupItemStatus.retry,</div><div>264:      Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>289:      _allBackups[id] = _allBackups[id]!</div><div>290:          .copyWith(status: BackupItemStatus.retry, error: reason);</div><div>291:      Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>371:        _allBackups[pendingEntry.file.localID!] =</div><div>372:            _allBackups[pendingEntry.file.localID]!</div><div>373:                .copyWith(status: BackupItemStatus.uploading);</div><div>374:        Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>432:      _allBackups[localID] =</div><div>433:          _allBackups[localID]!.copyWith(status: BackupItemStatus.uploaded);</div><div>434:      Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>439:        _allBackups[localID] = _allBackups[localID]!</div><div>440:            .copyWith(status: BackupItemStatus.inBackground);</div><div>441:        Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>445:        _allBackups[localID] = _allBackups[localID]!</div><div>446:            .copyWith(status: BackupItemStatus.retry, error: e);</div><div>447:        Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>565:    final isInQueue = _allBackups[file.localID!] != null;</div><div>569:        _allBackups[file.localID!] = _allBackups[file.localID]!.copyWith(</div><div>570:          status: BackupItemStatus.uploaded,</div><div>572:        Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>577:        _allBackups[file.localID!] = _allBackups[file.localID]!.copyWith(</div></div></div></div><div class="tool-execution" style="background-color: rgb(40, 50, 40)"><div class="tool-command">$ cat /Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/models/backup/backup_item.dart</div><div class="tool-output expandable" onclick="this.classList.toggle('expanded')"><div class="output-preview"><div>import &quot;dart:async&quot;;</div><div></div><div>import &quot;package:photos/models/backup/backup_item_status.dart&quot;;</div><div>import &quot;package:photos/models/file/file.dart&quot;;</div><div></div><div class="expand-hint">... (55 more lines) - click to expand</div></div><div class="output-full"><div>import &quot;dart:async&quot;;</div><div></div><div>import &quot;package:photos/models/backup/backup_item_status.dart&quot;;</div><div>import &quot;package:photos/models/file/file.dart&quot;;</div><div></div><div>class BackupItem {</div><div>  final BackupItemStatus status;</div><div>  final EnteFile file;</div><div>  final int collectionID;</div><div>  final Completer&lt;EnteFile&gt;? completer;</div><div>  final Object? error;</div><div></div><div>  BackupItem({</div><div>    required this.status,</div><div>    required this.file,</div><div>    required this.collectionID,</div><div>    required this.completer,</div><div>    this.error,</div><div>  });</div><div></div><div>  BackupItem copyWith({</div><div>    BackupItemStatus? status,</div><div>    EnteFile? file,</div><div>    int? collectionID,</div><div>    Completer&lt;EnteFile&gt;? completer,</div><div>    Object? error,</div><div>  }) {</div><div>    return BackupItem(</div><div>      status: status ?? this.status,</div><div>      file: file ?? this.file,</div><div>      collectionID: collectionID ?? this.collectionID,</div><div>      completer: completer ?? this.completer,</div><div>      error: error ?? this.error,</div><div>    );</div><div>  }</div><div></div><div>  @override</div><div>  String toString() {</div><div>    return &#039;BackupItem(status: $status, file: $file, collectionID: $collectionID, error: $error)&#039;;</div><div>  }</div><div></div><div>  @override</div><div>  bool operator ==(covariant BackupItem other) {</div><div>    if (identical(this, other)) return true;</div><div></div><div>    return other.status == status &amp;&amp;</div><div>        other.file == file &amp;&amp;</div><div>        other.collectionID == collectionID &amp;&amp;</div><div>        other.completer == completer &amp;&amp;</div><div>        other.error == error;</div><div>  }</div><div></div><div>  @override</div><div>  int get hashCode {</div><div>    return status.hashCode ^</div><div>        file.hashCode ^</div><div>        collectionID.hashCode ^</div><div>        completer.hashCode;</div><div>  }</div><div>}</div></div></div></div><div class="tool-execution" style="background-color: rgb(40, 50, 40)"><div class="tool-command">$ grep -r &quot;BackupUpdatedEvent&quot; /Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib --include=&quot;*.dart&quot; | grep -v &quot;generated&quot; | head -20</div><div class="tool-output expandable" onclick="this.classList.toggle('expanded')"><div class="output-preview"><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/settings/backup/backup_status_screen.dart:    checkBackupUpdatedEvent();</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/settings/backup/backup_status_screen.dart:  void checkBackupUpdatedEvent() {</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/settings/backup/backup_status_screen.dart:        Bus.instance.on&lt;BackupUpdatedEvent&gt;().listen((event) {</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/utils/file_uploader.dart:      Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/utils/file_uploader.dart:      Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div class="expand-hint">... (11 more lines) - click to expand</div></div><div class="output-full"><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/settings/backup/backup_status_screen.dart:    checkBackupUpdatedEvent();</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/settings/backup/backup_status_screen.dart:  void checkBackupUpdatedEvent() {</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/ui/settings/backup/backup_status_screen.dart:        Bus.instance.on&lt;BackupUpdatedEvent&gt;().listen((event) {</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/utils/file_uploader.dart:      Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/utils/file_uploader.dart:      Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/utils/file_uploader.dart:      Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/utils/file_uploader.dart:        Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/utils/file_uploader.dart:      Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/utils/file_uploader.dart:        Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/utils/file_uploader.dart:        Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/utils/file_uploader.dart:        Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/utils/file_uploader.dart:        Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/utils/file_uploader.dart:      Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/utils/file_uploader.dart:        Bus.instance.fire(BackupUpdatedEvent(_allBackups));</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/events/backup_updated_event.dart:class BackupUpdatedEvent extends Event {</div><div>/Users/prateeksunal/dev/enteio/ente/mobile/apps/photos/lib/events/backup_updated_event.dart:  BackupUpdatedEvent(this.items);</div></div></div></div><div class="assistant-text">Now I have a complete understanding of the issue. Let me summarize my findings and prepare a detailed plan:<br><br>---<br><br># Plan: Fix Backup Folder Selection Not Reflecting Immediately in Sync Queue<br><br>## Problem Analysis<br><br>When users select/deselect backup folders, the changes are not immediately reflected in the running sync process. This leads to:<br>1. **Stale file uploads**: Files from deselected folders continue to upload<br>2. **Missing file uploads**: Files from newly selected folders don&#039;t get picked up immediately<br>3. **User confusion**: The sync queue doesn&#039;t match the current folder selection<br><br>## Current Flow Analysis<br><br>### Current Architecture<br><br>1. **Folder Selection UI** (`backup_folder_selection_page.dart`, `device_folder_page.dart`)<br>   - Calls `RemoteSyncService.instance.updateDeviceFolderSyncStatus(syncStatus)`<br><br>2. **RemoteSyncService.updateDeviceFolderSyncStatus()** (`remote_sync_service.dart:455-477`)<br>   ```dart<br>   Future&lt;void&gt; updateDeviceFolderSyncStatus(Map&lt;String, bool&gt; syncStatusUpdate) async {<br>     final Set&lt;int&gt; oldCollectionIDsForAutoSync = await _db.getDeviceSyncCollectionIDs();<br>     await _db.updateDevicePathSyncStatus(syncStatusUpdate);<br>     final Set&lt;int&gt; newCollectionIDsForAutoSync = await _db.getDeviceSyncCollectionIDs();<br>     SyncService.instance.onDeviceCollectionSet(newCollectionIDsForAutoSync);<br>     // ... removes from DB<br>   }<br>   ```<br><br>3. **SyncService.onDeviceCollectionSet()** (`sync_service.dart:143-150`)<br>   ```dart<br>   void onDeviceCollectionSet(Set&lt;int&gt; collectionIDs) {<br>     _uploader.removeFromQueueWhere(<br>       (file) =&gt; !collectionIDs.contains(file.collectionID),<br>       UserCancelledUploadError(),<br>     );<br>   }<br>   ```<br><br>4. **FileUploader.removeFromQueueWhere()** (`file_uploader.dart:273-295`)<br>   - Only removes files with `UploadStatus.notStarted`<br>   - Files already `inProgress` or `inBackground` continue uploading<br><br>### Identified Gaps<br><br>| Gap | Description | Location |<br>|-----|-------------|----------|<br>| **Gap 1** | In-progress uploads are not cancelled when folder is deselected | `FileUploader.removeFromQueueWhere()` only handles `notStarted` status |<br>| **Gap 2** | Files queued in DB but not yet in uploader queue still get uploaded | `_getFilesToBeUploaded()` re-reads from DB on next sync iteration |<br>| **Gap 3** | No immediate cancellation of actively uploading files | Missing cancellation token/abort mechanism |<br>| **Gap 4** | New folder selection requires waiting for next sync cycle | No immediate re-sync trigger after folder selection changes |<br><br>---<br><br>## Proposed Solution<br><br>### Phase 1: Immediate Queue Cleanup (Quick Win)<br><br>#### 1.1 Enhance `removeFromQueueWhere` to cancel in-progress uploads<br><br>**File:** `lib/utils/file_uploader.dart`<br><br>```dart<br>void removeFromQueueWhere(<br>  final bool Function(EnteFile) fn,<br>  final Error reason, {<br>  bool cancelInProgress = false,  // New parameter<br>}) {<br>  final List&lt;String&gt; uploadsToBeRemoved = [];<br>  _queue.entries<br>      .where((entry) =&gt; <br>          entry.value.status == UploadStatus.notStarted ||<br>          (cancelInProgress &amp;&amp; entry.value.status == UploadStatus.inProgress))<br>      .forEach((pendingUpload) {<br>    if (fn(pendingUpload.value.file)) {<br>      uploadsToBeRemoved.add(pendingUpload.key);<br>    }<br>  });<br>  // ... rest of the method<br>}<br>```<br><br>#### 1.2 Update `onDeviceCollectionSet` to pass `cancelInProgress: true`<br><br>**File:** `lib/services/sync/sync_service.dart`<br><br>```dart<br>void onDeviceCollectionSet(Set&lt;int&gt; collectionIDs) {<br>  _uploader.removeFromQueueWhere(<br>    (file) =&gt; !collectionIDs.contains(file.collectionID),<br>    UserCancelledUploadError(),<br>    cancelInProgress: true,  // Cancel active uploads too<br>  );<br>}<br>```<br><br>### Phase 2: Add Upload Cancellation Token Support<br><br>#### 2.1 Add cancellation token to upload process<br><br>**File:** `lib/utils/file_uploader.dart`<br><br>Create a `CancellationToken` mechanism:<br><br>```dart<br>class UploadCancellationToken {<br>  bool _isCancelled = false;<br>  bool get isCancelled =&gt; _isCancelled;<br>  void cancel() =&gt; _isCancelled = true;<br>}<br><br>class FileUploadItem {<br>  // ... existing fields<br>  UploadCancellationToken? cancellationToken;<br>}<br>```<br><br>Modify `_encryptAndUploadFileToCollection` to check cancellation:<br><br>```dart<br>Future&lt;EnteFile?&gt; _encryptAndUploadFileToCollection(...) async {<br>  final cancellationToken = _queue[localID]?.cancellationToken;<br>  <br>  // Check before each major operation<br>  if (cancellationToken?.isCancelled ?? false) {<br>    throw UserCancelledUploadError();<br>  }<br>  // ... existing upload logic with periodic cancellation checks<br>}<br>```<br><br>#### 2.2 Update `removeFromQueueWhere` to use cancellation tokens<br><br>```dart<br>void removeFromQueueWhere(...) {<br>  // For in-progress uploads, cancel via token instead of removing<br>  _queue.entries<br>      .where((entry) =&gt; entry.value.status == UploadStatus.inProgress)<br>      .forEach((upload) {<br>    if (fn(upload.value.file)) {<br>      upload.value.cancellationToken?.cancel();<br>    }<br>  });<br>  // ... handle notStarted as before<br>}<br>```<br><br>### Phase 3: Improve DB-Level File Filtering<br><br>#### 3.1 Add real-time filtering in `_getFilesToBeUploaded`<br><br>**File:** `lib/services/sync/remote_sync_service.dart`<br><br>```dart<br>Future&lt;List&lt;EnteFile&gt;&gt; _getFilesToBeUploaded() async {<br>  final List&lt;EnteFile&gt; originalFiles = await _db.getFilesPendingForUpload();<br>  <br>  // Get current sync collection IDs at the moment of upload<br>  final Set&lt;int&gt; activeSyncCollectionIDs = await _db.getDeviceSyncCollectionIDs();<br>  <br>  // Filter out files from non-synced collections<br>  originalFiles.removeWhere((file) =&gt; <br>    file.collectionID != null &amp;&amp; <br>    !activeSyncCollectionIDs.contains(file.collectionID));<br>  <br>  // ... rest of existing filtering<br>}<br>```<br><br>### Phase 4: Trigger Immediate Re-sync After Folder Changes<br><br>#### 4.1 Add immediate sync trigger after folder selection<br><br>**File:** `lib/services/sync/remote_sync_service.dart`<br><br>```dart<br>Future&lt;void&gt; updateDeviceFolderSyncStatus(<br>  Map&lt;String, bool&gt; syncStatusUpdate,<br>) async {<br>  // ... existing logic<br>  <br>  // If new folders were selected, trigger immediate sync for new files<br>  final newlySelectedPaths = syncStatusUpdate.entries<br>      .where((e) =&gt; e.value == true)<br>      .map((e) =&gt; e.key)<br>      .toSet();<br>  <br>  if (newlySelectedPaths.isNotEmpty &amp;&amp; !SyncService.instance.isSyncInProgress()) {<br>    // Queue a sync to pick up newly selected folders<br>    unawaited(SyncService.instance.sync());<br>  }<br>}<br>```<br><br>### Phase 5: UI Feedback Improvements<br><br>#### 5.1 Add visual feedback for cancelled uploads<br><br>**File:** `lib/models/backup/backup_item_status.dart`<br><br>```dart<br>enum BackupItemStatus {<br>  inQueue,<br>  uploading,<br>  uploaded,<br>  inBackground,<br>  retry,<br>  cancelled,  // New status<br>}<br>```<br><br>#### 5.2 Update `_allBackups` to reflect cancelled status<br><br>**File:** `lib/utils/file_uploader.dart`<br><br>```dart<br>void removeFromQueueWhere(...) {<br>  for (final id in uploadsToBeRemoved) {<br>    _queue.remove(id)?.completer.completeError(reason);<br>    _allBackups[id] = _allBackups[id]!.copyWith(<br>      status: BackupItemStatus.cancelled,  // Use cancelled instead of retry<br>      error: reason,<br>    );<br>    Bus.instance.fire(BackupUpdatedEvent(_allBackups));<br>  }<br>}<br>```<br><br>---<br><br>## Implementation Order<br><br>1. **Phase 1** (Immediate Queue Cleanup) - Quick win, low risk<br>2. **Phase 3** (DB-Level Filtering) - Prevents future stale uploads<br>3. **Phase 4** (Immediate Re-sync) - Better UX for folder selection<br>4. **Phase 2** (Cancellation Tokens) - Cleaner abort mechanism, medium complexity<br>5. **Phase 5** (UI Feedback) - Polish, can be deferred<br><br>---<br><br>## Testing Checklist<br><br>- [ ] Deselect a folder → verify uploads from that folder stop immediately<br>- [ ] Deselect a folder with in-progress upload → verify current upload is cancelled<br>- [ ] Select a new folder → verify files start uploading immediately<br>- [ ] Toggle folder selection rapidly → verify no duplicate uploads or crashes<br>- [ ] Background sync with folder changes → verify background process respects changes<br>- [ ] Verify `BackupUpdatedEvent` fires correctly with new statuses<br>- [ ] Verify UI shows correct status for cancelled uploads<br><br>---<br><br>## Risks &amp; Mitigations<br><br>| Risk | Mitigation |<br>|------|------------|<br>| Cancelling in-progress uploads may leave partial data | Existing cleanup logic in `_onUploadDone` handles this |<br>| Race condition between folder toggle and sync | Use locks/synchronization in critical sections |<br>| Memory leak from cancelled completers | Ensure completers are properly completed with errors |<br>| Breaking existing upload retry logic | Keep retry logic separate from user-initiated cancellation |<br><br>---<br><br>## Files to Modify<br><br>| File | Changes |<br>|------|---------|<br>| `lib/utils/file_uploader.dart` | Add cancellation support, enhance `removeFromQueueWhere` |<br>| `lib/services/sync/sync_service.dart` | Update `onDeviceCollectionSet` |<br>| `lib/services/sync/remote_sync_service.dart` | Add filtering in `_getFilesToBeUploaded`, trigger re-sync |<br>| `lib/models/backup/backup_item_status.dart` | Add `cancelled` status |<br>| `lib/ui/settings/backup/backup_status_screen.dart` | Handle `cancelled` status in UI (optional) |</div><div class="user-message">what do you think about it?</div><div class="assistant-text">Overall, the plan is solid and will fix the bug. A few refinements will make it safer and easier to ship:<br><br>What looks good<br>- Removing not-started uploads immediately on folder change is correct and low risk.<br>- Re-filtering pending uploads by current device-sync collections at _getFilesToBeUploaded() prevents newly queued stale uploads.<br>- Triggering a sync after folder changes ensures newly selected folders start backing up quickly.<br>- Cleaning pending DB entries for deselected collections is already in place and good.<br><br>Key improvements I recommend<br>1) Use Dio CancelToken for real cancellation<br>- Add a CancelToken per FileUploadItem and pass it to every network call (single PUTs and multipart). _putFile already uses _dio.put; just add cancelToken.<br>- MultiPartUploader also needs cancelToken plumbed through its HTTP calls. If that’s too much for a first pass, you can scope cancellation to single-part uploads first, and let multipart finish, but mark as cancelled downstream (see 3).<br><br>2) Cancellation checkpoints, not fine-grained abort<br>- CryptoUtil.encryptFile[...] isn’t cancellable mid-encryption. That’s OK. Check the token at major boundaries:<br>  - Before upload URL fetch<br>  - Before each PUT/multipart part<br>  - Before metadata upload<br>- If cancellation is requested, throw UserCancelledUploadError so the code-path reuses existing error handling and cleanup.<br><br>3) Handle multipart cancellation cleanup explicitly<br>- Today _onUploadDone keeps encrypted multipart files if upload didn’t complete. For user-initiated cancellation, you don’t want to resume. On catching UserCancelledUploadError:<br>  - call UploadLocksDB.deleteMultipartTrack(lockKey)<br>  - delete the encrypted multipart file<br>  - release the lock<br>- Pass a wasCancelled flag into _onUploadDone or treat cancellation as a “hard failure” for cleanup.<br><br>4) Only cancel foreground in-progress uploads<br>- Background uploads (status inBackground) can’t be cancelled reliably; leave them alone. Your current logic already treats these separately via locks. Document this as the policy.<br><br>5) Immediate re-sync after folder change<br>- Your plan calls SyncService.sync() after updateDeviceFolderSyncStatus. Good. That runs syncDeviceCollectionFilesForUpload, which will map newly selected device folders to collections so new files get queued.<br><br>6) Tighten DB filtering<br>- Add current device-sync set filtering in _getFilesToBeUploaded() as proposed. This prevents any stale collection from re-entering the queue on the next cycle.<br><br>7) Optional but nice: reflect “cancelled” in UI<br>- If adding BackupItemStatus.cancelled, ensure backup_status_screen maps it to a user-friendly state (“Cancelled due to folder change”).<br>- If you want minimal surface change, you can reuse “retry” and a toast/snackbar explaining “Uploads from deselected folders were cancelled.”<br><br>Practical rollout order<br>- Phase 1 (remove not-started from queue) + Phase 3 (DB re-filter) + Phase 4 (trigger sync) will fix most reports quickly with low risk.<br>- Phase 2 (cancellation token) and multipart cleanup can follow; they’re the trickiest parts but worth it.<br>- Phase 5 (UI status) is polish.<br><br>Edge cases to cover in tests<br>- Deselect while a single-part upload is midway through PUT → cancel via CancelToken → no DB update, no stale resume.<br>- Deselect while multipart running:<br>  - If Phase 2 for multipart is not done yet, multipart may finish. Confirm no further files from that folder are queued, and DB cleanup runs for the rest.<br>  - After implementing multipart cancellation, ensure track and temp files are removed on cancellation.<br>- Select a new folder while a sync is running → verify immediate mapping and queuing without waiting for the next app lifecycle event.<br>- Rapid toggling selection → ensure no duplicate queueing and no crashes.<br>- Background uploads: make sure “inBackground” ones aren’t touched and foreground queue behaves as expected.<br><br>Bottom line<br>- Ship the quick wins first (queue cleanup, DB filtering, immediate sync). They address the core user pain now.<br>- Then add true in-flight cancellation with CancelToken and multipart cleanup for completeness.<br>- This approach is incremental, low-risk, and will stop stale uploads effectively.</div><div class="user-message">prepare a final plan based on the above feedback, sacrifice grammar for concision and don&#039;t make it too verbose. Use psuedo-code instead of real code in output.</div><div class="assistant-text"># Final Plan: Backup Folder Selection Sync Fix<br><br>## Root Cause<br>When user toggles folder backup selection, in-progress uploads continue and DB still has stale entries that get re-queued on next sync cycle.<br><br>## Implementation Phases<br><br>### Phase 1: Quick Wins (Ship First)<br><br>**1.1 Remove not-started uploads from queue immediately**<br><br>`file_uploader.dart` - `removeFromQueueWhere()`:<br>- Already works for `notStarted` status ✓<br>- No changes needed<br><br>**1.2 Filter stale collections in `_getFilesToBeUploaded()`**<br><br>`remote_sync_service.dart`:<br>```<br>_getFilesToBeUploaded():<br>  files = db.getFilesPendingForUpload()<br>  activeSyncCollectionIDs = db.getDeviceSyncCollectionIDs()  // ADD THIS<br>  files.removeWhere(f =&gt; f.collectionID not in activeSyncCollectionIDs)  // ADD THIS<br>  // ... existing video/ignored filtering<br>```<br><br>**1.3 Trigger sync after folder change**<br><br>`remote_sync_service.dart` - `updateDeviceFolderSyncStatus()`:<br>```<br>// after existing logic...<br>if (any syncStatusUpdate value == true):<br>  unawaited(SyncService.instance.sync())<br>```<br><br>---<br><br>### Phase 2: In-Flight Upload Cancellation<br><br>**2.1 Add CancelToken per upload**<br><br>`file_uploader.dart`:<br>```<br>FileUploadItem:<br>  + CancelToken? cancelToken<br><br>upload():<br>  item.cancelToken = CancelToken()<br><br>_putFile():<br>  pass cancelToken to _dio.put()<br><br>_getUploadURL():<br>  pass cancelToken to _enteDio requests<br>```<br><br>**2.2 Cancel in-progress uploads on folder deselect**<br><br>`file_uploader.dart`:<br>```<br>removeFromQueueWhere(fn, reason, {cancelInProgress = false}):<br>  // existing notStarted removal...<br>  <br>  if cancelInProgress:<br>    for entry in queue where status == inProgress:<br>      if fn(entry.file):<br>        entry.cancelToken?.cancel()<br>```<br><br>`sync_service.dart`:<br>```<br>onDeviceCollectionSet(collectionIDs):<br>  _uploader.removeFromQueueWhere(<br>    f =&gt; f.collectionID not in collectionIDs,<br>    UserCancelledUploadError(),<br>    cancelInProgress: true  // ADD THIS<br>  )<br>```<br><br>**2.3 Cancellation checkpoints in upload flow**<br><br>`file_uploader.dart` - `_encryptAndUploadFileToCollection()`:<br>```<br>// Check at major boundaries:<br>before _getUploadURL() → if cancelToken.isCancelled throw UserCancelledUploadError<br>before _putFile() → same check<br>before multipart upload → same check<br>before metadata upload → same check<br>```<br><br>**2.4 Cleanup on cancellation**<br><br>`file_uploader.dart` - `_onUploadDone()`:<br>```<br>+ wasCancelled parameter<br><br>if wasCancelled:<br>  delete encrypted file (even multipart)<br>  UploadLocksDB.deleteMultipartTrack(lockKey)<br>  // treat like hard failure for cleanup<br>```<br><br>Catch block in `_encryptAndUploadFileToCollection`:<br>```<br>catch UserCancelledUploadError:<br>  call _onUploadDone(..., wasCancelled: true)<br>```<br><br>---<br><br>### Phase 3: Polish (Optional)<br><br>**3.1 Add cancelled status**<br><br>`backup_item_status.dart`:<br>```<br>enum BackupItemStatus { ..., cancelled }<br>```<br><br>**3.2 UI feedback**<br><br>`backup_status_screen.dart`:<br>- Map `cancelled` to user-friendly message<br>- Or reuse `retry` + toast &quot;Uploads cancelled due to folder change&quot;<br><br>---<br><br>## Scope Boundaries<br><br>| In Scope | Out of Scope |<br>|----------|--------------|<br>| Foreground in-progress uploads | Background uploads (`inBackground` status) |<br>| Single-part PUT cancellation | Multipart cancellation (Phase 2, can defer) |<br>| Queue cleanup | Resumable upload cleanup (existing logic handles) |<br><br>---<br><br>## Files to Modify<br><br>| File | Phase |<br>|------|-------|<br>| `remote_sync_service.dart` | 1 |<br>| `file_uploader.dart` | 1, 2 |<br>| `sync_service.dart` | 2 |<br>| `backup_item_status.dart` | 3 |<br><br>---<br><br>## Test Cases<br><br>- [ ] Deselect folder → not-started uploads removed immediately<br>- [ ] Deselect folder → in-progress upload cancelled (Phase 2)<br>- [ ] Deselect folder → next sync cycle doesn&#039;t re-queue files from that folder<br>- [ ] Select new folder → files start uploading without app restart<br>- [ ] Rapid toggle → no duplicates, no crashes<br>- [ ] Background upload running → not affected by foreground folder changes<br><br>---<br><br>## Rollout<br><br>1. **Phase 1** → fixes 80% of user reports, low risk, ship immediately<br>2. **Phase 2** → cleaner UX, medium complexity, follow-up PR<br>3. **Phase 3** → polish, optional</div>
        </div>

        <div class="footer">
            Generated by pi coding-agent on 11/27/2025, 12:56:14 AM
        </div>
    </div>
</body>
</html>